<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../assets/styles/styles.css">
    <link rel="stylesheet" href="../assets/styles/prism.css">
    <script src="../assets/scripts/prism.js"></script>
    <script src="../assets/scripts/script.js"></script>
    <title>Java klasės pamoka.</title>
</head>
<body>
    <div class="page-container">
        <div class="sidebar-menu" id="sidebarMenu">
            <img id="sidebarArrow" class="arrow" src="../assets/img/menu-arrow-right.jpg" alt="Rodyklė rodanti į dešinę pusę, skirta atidaryti šoniniam meniu">
            <div class="sidebar-menu-text bold-text">SPAUSKITE NORINT ATIDARYTI MENIU</div>
            <ul id="sidebarMenuList">
                <li><a href="#section1">Meniu sąrašas</a></li>
            </ul>
        </div>

    

        <div class="main-content">
            <div class="section">
                <div class="section-header">
                    <h3 id="section1">Java klasės pamoka</h3>
                </div>
                <div class="theory-text">
                    <h4>Užduotis:</h4>
                    <ol class="example-list">
                        <li>Susikurti projektą bei PagrindinePrograma.java failą (klasę)</li>
                        <li>Susikurti "Knyga" klasę. Joje turėtų būti tokie kintamieji:</li>
                        <ul>
                            <li>isbn - knygos identifikacinis kodas sudarytas iš dešimt skaičių, atskirtų trim brūkšneliais. Pvz.: (95-8238-577-4) (iš viso 13 simbolių)</li>
                            <li>Pavadinimas</li>
                            <li>Autorius</li>
                            <li>Leidimo metai</li>
                            <li>Leidėjas</li>
                            <li>Šalis</li>
                            <li>Kaina</li>
                        </ul>
                        <li>Pagrindinėje programoje sukurti tokias funkcijas:</li>
                            <ul>
                                <li>Duomenų nuskaitymo - funkcija gauna String failoPavadinimas, o grąžina ArrayList&lt;Knyga&gt; - nuskaitytas knygas iš duomenų failo. Failo kurtis nereikia, jis yra įkeltas Discord’e.</li>
                                <li>Sumos - funkcija gauna Knygų ArrayList’ą, o turėtų grąžinti double skaičių - Knygų kainos sumą.</li>
                                <li>Vidurkio - funkcija gauna Knygų ArrayList’ą, o turėtų grąžinti double skaičių - Knygų kainos vidurkį.</li>
                                <li>Paieška - funkcija gauna String isbn, o turėtų grąžinti Knyga objektą - vieną knygą, kurios yra toks isbn</li>
                                <li>Funkciją, kuri gauna ArrayList&lt;Knyga&gt; knygos, o grąžina String šalis - šalies pavadinimą, iš kurios yra daugiausiai knygų. Galima daryti prielaidą, kad knygos gali būti tik iš šių šalių: "Chile, Costa Rica, Colombia, Cuba, Bolivia". Darant šią prielaidą, galima pasidaryti "dažnumo masyvą", kuriame bus penki skaičiai. Nulinis skaičius rodys kiek knygų yra iš Chile, pirmas kiek iš Costa Rica, antras iš Colombia ir t.t. Nusinulinti visus tuos skaičius. Tada eiti per visas Knygas, tikrinti jų šalį ir pridėti vienetą prie atitinkamo skaičiaus "dažnumo masyve". Galima šią užduotį (patogiau) daryti su HashMap, tačiau atsiklausti iš pradžių daugiau informacijos kaip tą padaryti.</li>
                                <li>Funkciją, kuri gauna ArrayList&lt;Knyga&gt; knygos, o grąžina String[3] topLeidyklos - top 3 leidyklas, pagal išleistų knygų skaičių.</li>
                                <li>Filtravimo - funkcija  gauna String autorius, ArrayList&lt;Knyga&gt; knygos, o turėtų grąžinti ArrayList&lt;Knyga&gt; - arraylist’ą, kuriame yra visos gauto autoriaus knygos.</li>
                                <li>Analogiškai padaryti filtravimą leidėjui ir šaliai.</li>
                                <li>Padaryti metų filtravimo funkciją, kuri gauna int metai, ArrayList&lt;Knyga&gt; knygos ir grąžintų ArrayList&lt;Knyga&gt; - ArrayList’ą tų knygų, kurios yra išleistos vėliau nei gauti metai.</li>
                                <li>Padaryti kainų nuo -iki filtravimą. Funkcija gauna double startKaina, double limitKaina, ArrayList&lt;Knyga&gt; knygos, o grąžina ArrayList&lt;Knyga&gt; - arraylist’ą knygų, kurios yra brangesnės nei startKaina, bet pigesnės nei limitKaina.</li>
                            </ul>
                        <li>Atlikti rikiavimą arba kuriant Comparator’ius viduje klasės arba naudojant Lambda funkcijų trumpinius.</li>
                        <ul>
                            <li>Rikiuoti pagal pavadinimą abėcėlės didėjančia tvarka</li>
                            <li>Rikiuoti pagal leidimo metus mažėjančia tvarka</li>
                            <li>Rikiuoti pagal kainą didėjančia tvarka</li>
                            <li>Rikiuoti pagal autorių, o jeigu autoriai tokie patys, tada rikiuoti pagal knygos pavadinimą (čia derėtų kurti Comparator su if’u if’e)</li>
                        </ul>

                    </ol>


                    <ul class="example-list">
                        <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot6.jpg" alt="Kodo foto"></div></span>
                        
                        <h4>Detalesni nurodymai bei pagalba</h4>
                        <li>Susikurti projektą bei PagrindinePrograma.java failą (klasę). Norint sužinoti/prisiminti, kaip tai padaryti, <a href="projekto_kurimas.html">spauskite čia</a> </li>
                        <li>PagrindinePrograma.java susikurkite main metodą (įraškite main ir pasirinkite, jog nereiktų rašyti viso ilgo teksto) <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot6.jpg" alt="Kodo foto"></div></span></li>
                        <li>Susikurkite Knyga.java failą (klasę) <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot7.jpg" alt="Kodo foto"></div></span></li>
                        <li>Joje turėtų būti tokie kintamieji:
                            <ul>
                                <li>isbn - knygos identifikacinis kodas sudarytas iš dešimt skaičių, atskirtų trim brūkšneliais. Pvz.: (95-8238-577-4) (iš viso 13 simbolių)</li>
                                <li>Pavadinimas</li>
                                <li>Autorius</li>
                                <li>Leidimo metai</li>
                                <li>Leidėjas</li>
                                <li>Šalis</li>
                                <li>Kaina</li>
                            </ul>
                            </li>
                        <li>isbn darysime String, kadangi skaičiai IR brūkšniukai (simboliai). Pavadinimas String, kadangi tai yra tekstas, Autorius taip pat String, kadangi tai yra tekstas. Leidimo metai int (integer), kadangi metai visada būna sveikas skaičius. Leidėjas String, kadangi tai tekstas (pavadinimas), šalis taip pat String, kadangi tai tekstas. Kaina yra double, kadangi tai skaičius su kableliu. Taip pat juos darome "private", kadangi tai yra klasės kintamieji <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot8.jpg" alt="Kodo foto"></div></span></li>
                        <li>Toliau, po kintamųjų (bet prieš klasės uždaromąjį riestinį skliaustą, kadangi norime viską daryti klasės viduje) spaudžiame dešinį pelės klavišą ir pasirenkame "Generate..." <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot9.jpg" alt="Kodo foto"></div></span></li>
                        <li>Toliau, renkamės "Constructor", kadangi kursimės konstruktorius. Vieną pilną, vieną tuščią. Taip derėtų pasidaryti visada, tačiau, kai reikia galima susikurti ir dalinai pilnų konstruktorių (nebūtina) <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot10.jpg" alt="Kodo foto"></div></span></li>
                        <li>Kad sukurti tuščią konstruktorių spaudžiame "Select none" <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot11.jpg" alt="Kodo foto"></div></span></li>
                        <li>Kad sukurti pilną konstruktorių vėl spaudžiame dešinį pelės klavišą, "Generate...", "Constructor" ir tada pažymime visus kintamuosius su CTRL klaviatūros mygtuku ir kairiu pelės klavišu. (arba tiesiog CTRL + A paspausti su klaviatūra) <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot12.jpg" alt="Kodo foto"></div></span></li>
                        <li>Spaudžiame "Ok" ir dabar kodas turėtų atrodyti štai taip: <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot13.jpg" alt="Kodo foto"></div></span></li>
                        <li>Toliau, generuojame getterius ir setterius. Kadangi klasės kintamieji yra private, jų negalime pasiekti tiesiogiai, tačiau jų reikšmę galime gauti per getterius, o nustatyti reikšmę per setterius. Tai yra speciali Javos taisyklė vadinama "enkapsuliacija". </li>
                        <li>Norint sugeneruoti getterius ir setterius, spaudžiame dešinį pelės klavišą, "Generate...", "Getter and Setter", pasirenkate visus ir spaudžiate "Ok".</li>
                        <li>Toliau, norint, jog mūsų Knyga klasės objektus išvestų atitinkamai į konsolę/failą, reikia sugeneruoti toString() metodą, kadangi, jei jo nebus - išves tiesiog objekto bitkodą, kuris mums nėra aktualus.</li>
                        <li>Spaudžiame dešinį, "Generate", toString(), pažymime visus ir spaudžiame "Ok". Jūsų kodas turėtų atrodyti taip:</li>

                        <div class="spoiler">
                            <div class="spoiler-content">
                                <pre><code class="language-java">
public class Knyga {
    private String isbn;
    private String pavadinimas;
    private String autorius;
    private int leidimoMetai;
    private String leidejas;
    private String salis;
    private double kaina;

    public Knyga() {
    }

    public Knyga(String isbn, String pavadinimas, String autorius, int leidimoMetai, String leidejas, String salis, double kaina) {
        this.isbn = isbn;
        this.pavadinimas = pavadinimas;
        this.autorius = autorius;
        this.leidimoMetai = leidimoMetai;
        this.leidejas = leidejas;
        this.salis = salis;
        this.kaina = kaina;
    }

    public String getIsbn() {
        return isbn;
    }

    public void setIsbn(String isbn) {
        this.isbn = isbn;
    }

    public String getPavadinimas() {
        return pavadinimas;
    }

    public void setPavadinimas(String pavadinimas) {
        this.pavadinimas = pavadinimas;
    }

    public String getAutorius() {
        return autorius;
    }

    public void setAutorius(String autorius) {
        this.autorius = autorius;
    }

    public int getLeidimoMetai() {
        return leidimoMetai;
    }

    public void setLeidimoMetai(int leidimoMetai) {
        this.leidimoMetai = leidimoMetai;
    }

    public String getLeidejas() {
        return leidejas;
    }

    public void setLeidejas(String leidejas) {
        this.leidejas = leidejas;
    }

    public String getSalis() {
        return salis;
    }

    public void setSalis(String salis) {
        this.salis = salis;
    }

    public double getKaina() {
        return kaina;
    }

    public void setKaina(double kaina) {
        this.kaina = kaina;
    }

    @Override
    public String toString() {
        return "Knyga{" +
                "isbn='" + isbn + '\'' +
                ", pavadinimas='" + pavadinimas + '\'' +
                ", autorius='" + autorius + '\'' +
                ", leidimoMetai=" + leidimoMetai +
                ", leidejas='" + leidejas + '\'' +
                ", salis='" + salis + '\'' +
                ", kaina=" + kaina +
                '}';
    }

    
}                                    
                                </code></pre>
                            </div>
                            <div class="spoiler-button">
                                <button></button>
                            </div>
                        </div>
                    </ul>

                    <ul class="example-list">
                        <li>Susikūrėme klasę, toliau reikia kurti funkcijas PagrindinePrograma faile. Atsidarome tą failą ir main funkcijos viduje susikuriame knygų ArrayList'ą - jame saugosime visas knygas bei String failoPavadinimas - čia bus failo pavadinimas, iš kurio skaitysime knygas. <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot14.jpg" alt="Kodo foto"></div></span></li>
                        <li>Toliau, kuriame funkciją, kuri nuskaitys knygas iš tekstinio failo. (po main uždaromojo riestinio skliausto) Funkcija gaus String failoPavadinimas. Taip darome, jog funkcija būtų universalesnė. Padarę, jog funkcija failo pavadinimą gautų, o ne visada nuskaitytų iš to pačio, mes padarome, jog funkcija veiktų su bet kokiais failais.</li>
                        <li>Kuriame funkciją rašydami "public static", toliau rašome kokį duomenų tipą funkcija grąžins. Šiuo atveju tai yra ArrayList&lt;Knyga&gt;, kadangi funkcija grąžins visas nuskaitytas knygas (ką kiekviena funkcija grąžins yra nurodyta ir šios užduoties nurodymuose). Toliau rašome funkcijos pavadinimą. Dedame paprastus skliaustus ir skliaustų viduje yrašome kokio duomenų tipo ir kokio pavadinimo parametrus gaus (String failoPavadinimas). Atidarome riestinius skliaustus ir pradedame funkciją. <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot15.jpg" alt="Kodo foto"></div></span></li>
                        <li>Toliau, funkcijoje reikia parašyti try ir catch blokus, kadangi vėlgi pagal Javos taisykles, norint skaityti iš failo būtina gaudyti FileNotFoundException. try bloke susikuriame File objektą (jam sukurti naudojame failoPavadinimas), toliau susikuriame Scanner objektą (jam naudojame File objektą, kurį susikūrėme prieš tai. Viskas turėtų atrodyti štai taip: <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot16.jpg" alt="Kodo foto"></div></span></li>
                        <li>Tai yra standartinė duomenų nuskaitymo iš failo procedūra. Jos nereikia mokėti atmintinai, tiesiog žinoti iš kur pasižiūrėti (pavyzdžiai), kadangi ji visada kartojasi. </li>
                        <li>Toliau, jau reikia skaityti duomenis ir juos išsaugoti. Ši procedūra yra dažnai panaši, tačiau nebūtinai visada tokia pati. Priklauso nuo to kaip duomenys yra išdėstyti/išsaugoti bei kokie duomenys ten yra.</li>
                        <li>Šioje užduotyje mūsų duomenys yra .csv faile, tai reiškias, jog kiekvienas "stulpelis" yra atskirtas kableliu. Pirmame stulpelyje yra isbn, antrame pavadinimas, trečiame autorius, ketvirtame leidimo metai ir t.t.</li>
                        <li>Norint nuskaityti visas knygas, reikia skaiyti kiekvieną eilutę iš tekstinio failo. Toliau, tą eilutę skaldyti per kablelius, kadangi kableliai skiria skirtingus stulpelius. Suskaldyta eilutė bus visada tokio pat dydžio String masyve. Taigi masyvo nulinis elementas visada bus isbn, masyvo pirmas elementas pavadinimas, masyvo antras bus autorius ir t.t. Kadangi, masyvas yra String tipo, kai kuriuos kintamuosius (int ir double) turėsime konvertuoti į jų tipus. Patogiausiai, jog nepasimesti yra susikurti papildomus "laikinus" kintamuosius kiekvienam stulpeliui ir kurį reikia konvertuoti. Toliau išsaugome tuos duomenis į Knyga objektą per konstruktorių arba setterius, o tą objektą į dedameį ArrayList'ą.</li>
                        <li>Šie žingsniai taip pat yra standartiniai nuskaitant tam tikros klasės objektus iš .csv failo</li>
                        <li>Toliau, pasižiūrėsime kiekvieną žingsnį detaliau</li>
                        <li>Nuskaitome pirmą eilutę, bet jos neišsaugome, kadangi ji mums yra nereikalinga. Toliau, sukame while ciklą, kol failoSkaitytuvas turi sekančių eilučių iš failo. Kitaip sakant sukam ciklą per visas failo eilutes. <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot17.jpg" alt="Kodo foto"></div></span></li>
                        <li>While ciklo viduje (šiuos veiksmus kartos kiekvienai eilutei) nuskaitome eilutę į String tipo kintamąjį. Eilutę išskaldome į String tipo masyvą. <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot18.jpg" alt="Kodo foto"></div></span></li>
                        <li>isskaldytaEilute yra String[] masyvas. Masyvo kintamuosius pasiekiame per laužtinius skliaustus. Kadangi, tekste eilutės yra išdėstytos ta pačia tvarka, tai isskaldytaEilute[0] visada bus isbn, isskaldytaEilute[1] visada bus pavadinimas, isskaldytaEilute[2] visada bus autorius ir t.t.</li>
                        <li>Žinodami tai, galime susikurti laikinus kintamuosius. Kadangi metai ir kaina nėra String tipo kintamieji - juos konvertuojame. <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot19.jpg" alt="Kodo foto"></div></span></li>
                        <li>Susikuriame naują Knygos objektą, į kurį su konstruktoriu ir sudėsime šiuos kintamuosius. <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot20.jpg" alt="Kodo foto"></div></span></li>
                        <li>Kadangi to nepadarėme prieš tai, tai dabar grįžtame truputį atgal ir susikuriame Knygų ArrayList'ą, kadangi neturėdame ArrayList'o, neturėsime į ką saugoti visas knygas. Kai jau susikuriame ArrayListą (prieš ciklą) tada galima ciklo viduje kiekvieną knygą vis addinti (pridėti) į arraylistą. Taip pat grąžiname tą ArrayList'ą per return po ciklo ir try bloko. <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot21.jpg" alt="Kodo foto"></div></span></li>
                        <li>Belieka šią funkciją panaudoti main dalyje bei jas išvesti su System.out.println, jog pasitikrintume ar tikrai gerai nuskaitė. Išvedimui pavyzdyje naudoju forEach išvedimą, jog kiekvieną knygą išvestų į atskirą eilutę ir taip būtų patogiau susitikrinti. <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot22.jpg" alt="Kodo foto"></div></span></li>
                    </ul>

                    <ul class="example-list">
                        <li>Toliau, reikia sukurti funkciją, kuri apskaičiuotų visų Knygų kainų sumą.</li>
                        <li>Vėlgi, funkciją kuriamės tokiu pačių principu: "public static duomenųTipas funkcijosPavadinimas(parametrai). Kur duomenų tipas bus double, kadangi kainos yra double, o jas sumuosime ir rezultatą grąžinsime. Funkcijos pavadinimas tai tiesiog gali būti kainuSuma. O parametrai, tai ką funkcija gaus - ši funkcija turėtų gauti knygų arraylistą, kurių kainų sumą skaičiuos. <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot23.jpg" alt="Kodo foto"></div></span></li>
                        <li>Kadangi tai yra panašiai kaip masyvo sumos funkcija, tai ir čia turime susikurti sumos kintamąjį ir jį "nusinulinti". <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot24.jpg" alt="Kodo foto"></div></span> <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot24.jpg" alt="Kodo foto"></div></span></li>
                        <li>Toliau reikia sukti ciklą, kuris pereitų per kiekvieną Knygą. Kitaip sakant for-each ciklą. Kad gautume geriausią for-each ciklo šabloną, rašome "iter" (be kabučių) ir spaudžiame enter arba pasirenkame su pele. Kai paspausite enter, turėtų išmesti tokį arba panašų šabloną: <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot25.jpg" alt="Kodo foto"></div></span></li>
                        <li>ciklo viduje "knygo" kintamasis yra vis skirtinga knyga, kurią paima kiekviename ciklo etape. Todėl, norėdami rasti visų knygų kainų sumą turime prie sumos vis pridėti "knygo" objekto kainą. Kadangi "knygo" yra Knyga objektas, negalime tiesiog sakyti "suma = suma + knygo", turime sakyti "suma = suma + knygo.getSuma()", kad nurodyti tiksliai kurį objekto kintamąjį turime omenyje. Sumą returniname ir funkcija yra baigta. <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot26.jpg" alt="Kodo foto"></div></span></li>
                    </ul>

                    <ul class="example-list">
                        <li>Toliau, reikia sukurti funkciją, kuri apskaičiuotų knygų kainų vidurkį.</li>
                        <li>Norint apskaičiuoti vidurkį reikia padalinti visų knygų kainų sumą iš visų knygų kiekio.</li>
                        <li>Sumos funkciją mes jau turime, tad ją galėsime pernaudoti. Knygų kiekį galime taip pat paimti, naudodami ArrayList metodą size(). Belieka tai užrašyti funkcijoje. Funkciją kuriame tuo pačiu šablonu, parametruose funkcija gaus arraylistą, funkcija grąžins double. Funkcijos viduje iš karto galime sakyti, kad grąžintų rezultatą suma dalinti iš kiekio: <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot27.jpg" alt="Kodo foto"></div></span></li>

                    </ul>

                    <ul class="example-list">
                        <li>Sekanti užduotis yra sukurti paieškos funkciją, kuri grąžintų visus Knygos duomenis funkcijai paduodant tik Knygos isbn. Funkciją vėl kuriamės tuo pačiu principu, per parametrus ji gaus String isbn - ieškomos Knygos isbn, o grąžins Knyga objektą - rastą knygą. <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot28.jpg" alt="Kodo foto"></div></span></li>
                        <li>Taip pat dar funkcija gaus ir knygų ArrayList. Funkcijos viduje vėlgi turime sukti ciklą, kuris eis per visas Knygas, taigi vėl rašome "iter" ir spaudžiame enter. <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot28.jpg" alt="Kodo foto"></div></span></li>
                        <li>Vėlgi, "knygo" yra vis sekančios Knygos objektas. Taigi turime eiti per visas Knygas ir tikrinti ar tos Knygos isbn sutampa su mūsų ieškomu isbn. Jeigu sutampa - grąžiname tą knygą, jeigu ne - sukame ciklą toliau. <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot30.jpg" alt="Kodo foto"></div></span></li>
                        <li>Detaliau išnagrinėti if'ą galime su šiuo paveiksliuku: <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot31.jpg" alt="Kodo foto"></div></span></li>
                        <li>Galiausiai, po ciklo reikia dar parašyti "return null", taip darome todėl, nes jeigu perėjus per visas Knygas nei viena iš jų netenkins if sąlygos (nei vienas isbn nesutaps su ieškomu), tai tada turime grąžinti null (tuščią objektą) <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot32.jpg" alt="Kodo foto"></div></span></li>

                    </ul>

                    <ul class="example-list">
                        <li>Kitoje užduotyje reikia surasti kiek knygų yra išspausdinta kiekvienoje valstybėje. Šią užduotį galima daryti dviem būdais. Bus aptarti bei parodyti su pavyzdžiais abu būdai.</li>
                        <li>Pirmas būdas</li>
                        <li>Jog būtų lengviau, galima daryti prielaidą, jog knygos yra tik iš šių šalių: "Chile, Costa Rica, Colombia, Cuba, Bolivia".</li>
                        <li>Tada, susikuriame int[5] masyvą, kuriame bus 5 elementai.</li>
                        <li>Kiekviena iš masyvų vietų atitinkamai priklausys šalies knygų skaičiui. Pavyzdžiui, nulinėje masyvo vietoje skaičiuosime kiek knygų yra Chile, pirmoje masyvo vietoje skaičiuosime kiek yra knygų išleista Costa Rica šalyje, antroje vietoje skaičiuosime kiek knygų yra išleista colombia ir t.t. <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot33.jpg" alt="Kodo foto"></div></span></li>
                        <li>Viršutiniame paveiksliuky pavaizduota kaip atrodo ką tik sukurtas dažnumo masyvas ir paaiškinimas, ką kiekvienoje vietoje saugotume.</li>
                        <li>Toliau, eitume per visas knygas ir tikrintume kiekvieną knygą iš kokios šalies ji yra. Tikrinimą darytume su if'u ir tada su dar vienu if'u nurodytume į kurią dažnumo masyvo pridėti +1. T.y., jeigu "Chile", tai turėtume daryti daznumoMasyvas[0]++, jeigu "Costa Rica", tai daznumoMasyvas[1]++, jei "Colombia", tai daznumoMasyvas[2] ir t.t.</li>
                        <li>Perėję per visas knygas turėtume dažnumo masyvą, kuriame būtų surašyta kiek knygų yra išleista kiekvienoje vasltybėje.</li>
                        <li>Tada belieka susikurti didziausioIndekasas(int[] masyvas) funkciją, kuri gauna masyvą ir grąžina didžiausio skaičio indeksą masyve. Jeigu jų yra du arba daugiau - grąžinti pirmo didžiausio. Pagal šios funkcijos rezultatą, su if'u tikrindami mes galime nustatyti, kurioje šalyje daugiausia išleista knygų. Jeigu funkcija grąžins 0, knygų daugiausia išleista Chile, jei funkcija grąžins 1, tai knygų daugiausia išleista Costa Rica, jeigu 2, tai Colombia ir t.t.</li>
                        <li>Belieka ištestuoti funkciją ją panaudojant main() programos dalyje.</li>
                        <li>Toliau, yra detalūs nurodymai kaip reikėtų tai įgyvendinti kode:</li>
                        <li>Kuriamės funkciją, ji per parametrus gaus knygų ArrayList'ą, o grąžins šalies pavadinimą (String), kurioje yra daugiausia knygų.<span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot34.jpg" alt="Kodo foto"></div></span></li>
                        <li>Funkcijos viduje susikuriame dažnumo masyvą. Javoje int[] masyvų reikšmės yra automatiškai nunulintos, tad jų keisti nereikia, užtenka sukurti. <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot35.jpg" alt="Kodo foto"></div></span></li>
                        <li>Paskui, sukame for-each (rašome "iter") ciklą per visas knygas ir kiekvieną iš tų knygų su if sąlyginiu sakiniu tikriname kokioje šalyje ji yra išleista. Jeigu Chile, tai tada pliusuojame nulinę dažnumo masyuvo vietą, jeigu Costa Rica, tai plusiuojame pirmą vietą, jeigu Colombia, tai antrą ir t.t. <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot36.jpg" alt="Kodo foto"></div></span></li>
                        <li>P.S. Po sunkesnių žingsnių, net jei ir to nerodo pavyzdys, VISADA yra gera idėja išsivesti į konsolę ir pasitikrinti ar gaunamas tinkamas rezultatas.</li>
                        <li>Toliau, reikia susikurti maxIndex() funkciją, kuri randa didžiausio skaičiaus indeksą masyve. (kelintas skaičius yra didžiausias). Geriau būtų, žinoma, tai pasidaryti atskiroje funkcijoje. <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot37.jpg" alt="Kodo foto"></div></span></li>
                        <li>Kai pasidarėme maxIndex() metodą, tada galime jį naudoti kuriojeSalyjeDaugiausia() metodo viduje. maxIndex() grąžins skaičių, kuris nurodys kelintoj šalyj yra daugiausia knygų. Taigi vėl reikės su if'u tikrinti, jeigu 0 - tada Chile, jeigu 1 - Costa Rica ir t.t. <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot38.jpg" alt="Kodo foto"></div></span></li>
                        <li>Dabar reikia panaudoti šį metodą pagrindinės programos dalyje ir išvesti rezultatą. <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot39.jpg" alt="Kodo foto"></div></span></li>
                        
                        
                        <li>Antras būdas</li>
                        <li>Tačiau su pirmu būdu šią užduotį išspręsti yra truputį nepatogu, kadangi iš pradžių su if'u reikia tikrinti šalies pavadinimą ir pagal jį įdėti į atitinkamą vietą masyve. Toliau programoje reikia su if'u tikrinti kuri masyvo vieta (indeksas) turi didžiausią skaičių ir vėl tą masyvo  vietą (indeksą) susieti su šalies pavadinimu.</li>
                        <li>Taip pat, jeigu norėtume perdaryti programą, jog ji veiktų su bet kokiomis šalimis, o ne iš anksto parinktomis, reikėtų ją patobulinti, sukuriant dar vieną masyvą, kuriame saugosime šalių pavadinimus, kitą kuriame saugosime kiekius. Galima būtų juos įdėti ir į naujai sukurtą klasę Daznumas, tačiau tai vis vien yra nepatogūs būdai, kurie prideda papildomo kodo bei yra lėtesni, kadangi patikrinti ar tokia reikšmė yra masyve gali užtrukti tiek operacijų, kiek yra elementų masyve. Kai tuo tarpu sekančioje duomenų struktūroje, kurią žiūrėsime tai užtrunka tik vieną operaciją. <a href="https://www.geeksforgeeks.org/understanding-time-complexity-simple-examples/">Daugiau apie time-complexity skaitykite čia (angliškai. bendrai apie time-complexity, o ne šiam pavyzdžiui)</a></li>
                        <li>Vietoj dviejų masyvų, mes galime naudoti "hashinimą" (mūsų pavyzdyje tai dviejų duomenų susiejimas tarpusavyje, tačiau bendrai tai gali būti ir vieno kintamojo susiejimas su tam tikru hashcode)</li>
                        <li>Hashinimas šiuo atveju bus mūsų šalių susiejimas su kiekiu knygų išleistų toje šalyje. Kadangi hashinsime du kintamuosius tarpusavyje - naudosime <a href="https://www.geeksforgeeks.org/java-util-hashmap-in-java-with-examples/">HashMap</a></li>
                        <li>HashMap'as tai yra duomenų struktūra, kuri iš tikrųjų daug nesiskiria nuo masyvo. HashMap galima atvaizduoti tokia pat lentele kaip ir masyvą. Tik vietoj indekso (masyve) yra raktas (mape). Taip pat, map'o raktas tai ne tik iš eilės sunumeruoti skaičiai, bet bet kokio duomenų tipo kintamasis, todėl gali būti ir String (šalis). <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot40.jpg" alt="Kodo foto"></div></span></li>
                        <li>Taigi, norėdami gauti kiek yra knygų Colombia, masyve turėtume rašyti masyvas[2], kadangi 2 yra Colombia indeksas. Tačiau, mape rašytume: map.get("Colombia") ir nesvarbu kelinta ta Colombia yra map'e, mums iš karto gautų jos knygų kiekį.</li>
                        <li>Norėdami įdėti naują reikšmių porą į map'ą, rašytume: map.put("Chile", 1)</li>
                        <li>Tačiau put komanda ne tik įdeda naują reikšmę, bet jeigu jau tokia pora yra, tai tos poros pakeičia value (antrą reikšmę, šiuo metu skaičių)</li>
                        <li>Todėl, norint vis tą reikšmę pliusuoti, reikia tikrinti ar tokia reikšmė egzistuoja ir į jos vietą naujai įdėti ją pačią padidintu vienu vienetu (value + 1). O tai atrodys truputį "sudėtingiau", kadangi pliusavimas užrašomas map.put("Chile", map.get("Chile") + 1). Kadangi reikia dar ir gauti tą reikšmę, jog galėtume prie jos pliusuoti ir ją tuo pačiu įdėti naujai.</li>
                        <li>Taigi visas algoritmas atrodytų taip: einame per visas knygas ir tikriname kokia knygos šalis, tada tikriname ar tokia šalis egzistuoja mape kaip raktas (key). Jeigu egzsistuoja, pliusiname to rakto (key) reikšmę (value) vienetu ir sukame ciklą toliau, jeigu neegzistuoja įdedame naują raktą, kurio reikšmė bus 1 (kadangi radome pirmą tos šalies knygą)</li>
                        <li>Kai pereisime per visas knygas belieka rasti, kuri mapo reikšmė yra didžiausia ir išvesti tos reikšmės raktą.</li>
                        <li>Belieka viską įgyvendinti kode. Pradedame nuo funkcijos sukūrimo. Funkcija gaus knygų arraylistą, o grąžins HashMap, kadangi šią funkciją galėsime pernaudoti ir top leidyklos užduočiai. rašome HashMap&lt;RAKTO_DUOMENŲ_TIPAS, REIKŠMĖS_DUOMENŲ_TIPAS&gt; šiuo atveju tai būtų HashMap&lt;String, Integer&gt;<span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot41.jpg" alt="Kodo foto"></div></span></li>
                        <li>Funkcijos viduje kuriamės naują HashMap'ą (jį reikės užpildyti ir grąžinti funkcijos returnu) <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot42.jpg" alt="Kodo foto"></div></span></li>
                        <li>Sukame For-each ciklą per visas knygas ir paimame šalį iš kurios yra ta knyga. Tada, tą šąlį tikriname su map'u - ar yra jau toks key mape. Jeigu yra - pliusuojame prie jo, jeigu nėra - įdedame vienetą. <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot43.jpg" alt="Kodo foto"></div></span></li>
                        <li>Kadangi HashMap yra naujas dalykas, jį tikrai derėtų pasitikrinti ir išsivesti. Norint tai padaryti, reikėtų grąžinti HashMap'ą ir jį išsivesti main dalyje. PASTABA: pervadinau funkciją į knygoSaliesDaznumoMapRadimas(), kadangi ji grąžina tik map, didžiausios dar neranda. <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot44.jpg" alt="Kodo foto"></div></span> <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot45.jpg" alt="Kodo foto"></div></span></li>
                        <li>Dabar, reikia padaryti funkciją, kuri randa maksimum reikšmę map'e ir grąžina tos reikšmės raktą. Kitaip sakant, funkciją kuri ras, kurioje šalyje yra daugiausia knygų. Susikuriame funkciją, ji grąžins String - šalį, kurioje yra daugiausia knygų, o gaus HashMap - dažnumo map. Funkcijos viduje susikuriame Map.Entry objektą, kuriame vis saugosime didžiausią porą. Map.Entry tai tiesiog vienos map'o poros objektas. Porą padarome iš pradžių null (tuščią) <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot46.jpg" alt="Kodo foto"></div></span></li>
                        <li>Tada, einame per visą mapą ir tikriname ar kuri nors iš reikšmių yra didesnė už dabartinę max porą arba jeigu dabartinė max pora yra tuščia (null), tai tada irgi radome naują max porą. </li>
                        <li>Rašome "iter" ir tada pasirenkame entrySet() nustatymą <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot47.jpg" alt="Kodo foto"></div></span> <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot48.jpg" alt="Kodo foto"></div></span></li>
                        <li>Ciklo viduje darome if'ą, kuriame ir tikriname jeigu maxPora yra tuščia ARBA jeigu dabartinės map'o poros value yra didesnė už max poros value. Jeigu bent viena iš salygų tenkina - dabartinė pora turi būti nustatyta max pora. <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot49.jpg" alt="Kodo foto"></div></span></li>
                        <li>Belieka panaudoti funkciją. <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot50.jpg" alt="Kodo foto"></div></span></li>

                        <li>Sekanti užduotis: TOP 3 leidyklos. Norint rasti top 3 leidyklas, iš pradžių reikia rasti kiek kiekviena leidykla išleido knygų. Tai padaryti naudosime tokią pačią dažnumo mapo radimo funkciją. Pradedame susikurdame funkciją. Rašome "public static", tada funkcijos duomenų tipą (kokį duomenų tipą funkcija grąžins), funkcijos pavadinimą ir skliausteliuose funkcijos parametrus. <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot51.jpg" alt="Kodo foto"></div></span></li>

                        <li>Funkcijos viduje susikuriame naują tuščią HashMap. HashMap viduje key (raktas) bus String tipo, kadangi raktai bus leidyklų pavadinimai, o value (reikšmė) bus kiek knygų išleido (sveikas skaičius). Į šį HashMap mes skaičiuosime dažnumą ir jį funkcijos pabaigoje grąžinsime kaip rezultatą. <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot52.jpg" alt="Kodo foto"></div></span></li>

                        <li>Norint suskaičiuoti dažnumą, reikia eiti per visas knygas, todėl sukame for-each ciklą. Rašome "iter" ir pasirenkame "knygos", kadangi reiks eiti per knygas. <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot53.jpg" alt="Kodo foto"></div></span> <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot54.jpg" alt="Kodo foto"></div></span></li>
                        <li>Ir su kiekviena knyga atlikti tokį veiksmą: paimti knygos leidėjo pavadinimą ir patikrinti ar map'e jau toks raktas egzistuoja (toks pat kaip leidyklos pavadinimas), jeigu egzistuoja, tai prie to rakto reikšmės (value) pridedam vienetą. Jeigu dar neegzistuoja, tai sukuriame naują rakto ir value porą, su map.put(key, value) funkcija. Vietoj key rašome leidyklos pavadinimą, o vietoj value rašome vienetą. <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot55.jpg" alt="Kodo foto"></div></span></li>

                        <li>Kai turime map'ą, belieka rasti tris maksimumus. Viskas panašiai kaip ir praeitoje užduotyje - reikėtų susikurti funkciją, kurioje susikuriame tris max kintamuosius. Einame per visą map'ą ir tikriname ar dabartinis map'o value yra didesnis už pirmą maximumą, jeigu taip tai jį dedame į pirmą maximumą, o pirmą ir antrą pastumiame į apačią, trečią ištriname. Jeigu nedidesnis už pirmą, tada tikriname ar didesnis už antrą, jeigu taip tai pakeičiame ir tuos kitus nustumiame žemyn, paskutinį ištriname. Ir taip toliau. Kadangi užduotyje yra nurodyta tik TOP 3, tai užtektų tiesiog su if'ais pasidaryti. Jeigu reikėtų padaryti TOP X, jog veiktų su bet kokiu top skaičiumi, tai reikėtų susikurti papildomą duomenų struktūrą, kuri yra vadinoma <a href="https://www.geeksforgeeks.org/max-heap-in-java/">MaxHeap</a>. Tai būtų nauja klasė ir naudotume jos objektą kelių max elementų radimui. </li>
                        <li>Tačiau, kad nereikėtų papildomai užkrauti papildoma duomenų struktūra, galime šią užduotį pasidaryti tiesiog HashMap'ą surikiuodami ir grąžindami kelis pirmus elementus.</li>
                        <li>Paprasčiausias būdas surikiuoti map'ą būtų perdėti jį į TreeMap. Pagal apibrėžimą TreeMap yra map'as, kuris yra surikiuotas pagal raktus. Tačiau, kadangi mums reikia surikiuoti pagal reikšmes, tai reikia sukurti dar vieną naują comparatorių. Susikuriame comparatorių, kuris nurodo, kad rikiuoti, pagal reikšmes, o ne raktus. Tą comparatorių susikuriame atskiroje klasėje. <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot56.jpg" alt="Kodo foto"></div></span></li>
                        <li>Kaip parašyti šį Comparator žinoti nėra būtina, bet bent jau kaip pakeisti pagal poreikį reikėtų. Ketvirtoje eilutėje užsirašome klasės pavadinimą, pradžia visada tokia pati, galite pavadinimą rašyti klasei ir kitokį. Klasės viduje susikuriame "base" kintamąjį - jis bus map'as, kuriam bus naudojamas rikiavimas. Toliau susikuriame konstruktorių. Konstruktorius gaus map'ą, kuriam reikės šito Comparatoriaus. Bei turime compare funkciją. Ji gauna String a ir String b. a ir b bus raktai, tad funkcijos viduje gauna tų raktų reikšmę ir ją palygina. Tad jei norėtume, kad rikiuotų mažėjančia tvarka, reikėtų if'e pakeisti į mažiau arba lygu ženklą. </li>
                        <li>Kai turime palygintuvą (Comparator), galime kurtis naują funkciją, kurioje surikiuosime Map'ą. Funkcija gauna HashMap'ą (mapą, kurį rikiuosime), o grąžina TreeMap (surikiuotą mapą). <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot57.jpg" alt="Kodo foto"></div></span></li>
                        <li>Susikuriame ValueComparator objektą vlc, jis gauna rikiuojamą mapą. Toliau, susikuriame TreeMap (surikiuoto mapo) objektą, jis gauna vlc objektą, kad žinotų pagal ką rikiuoti. Pakol kas TreeMap yra dar tuščias. <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot58.jpg" alt="Kodo foto"></div></span></li>
                        <li>Sudedame visus elementus iš HashedMap iš TreeMap. Kadangi TreeMap pagal apibrėžimą yra surikiuotas map'as pagal raktus, tačiau jam padavėme kitą comparatorių, jog rikiuotų pagal reikšmes, tai tiesiog perdėjimas iš HashMap į TreeMap surikiuos mūsų mapą. Galime grąžinti surikiuotą mapą. <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot59.jpg" alt="Kodo foto"></div></span></li>
                        <li>Galima pasitikrinti, ar rikiavimas tikrai veikia. <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot60.jpg" alt="Kodo foto"></div></span></li>
                        <li>Dabar, reikia padaryti funkciją, kuri išvestų tik kelis pirmus map'o elementus (top 3, top x). Kuriamės naują funkciją, kuri gaus map'ą bei grąžins taip pat mapą, tiesiog gautam map'e bus visos leidkylos (map'o poros), o grąžinamam map'e jau bus tik pirmos kelios poros. Taip pat funkcija per parametrus turėtų gauti int limitas, jog žinotume kelis pirmus top išvesti. <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot61.jpg" alt="Kodo foto"></div></span></li>
                        <li>Kadangi, Map'as neturi indeksų, tai negalime sukti for-i ciklo ir išvesti nuo-iki. Tad turime susikurti naują kintamajį "kelintas", jį nusinulinti ir sukti for-each ciklą, iš surikiuoto map'o paimame kiekvieną porą ir ją perdedame į naują map'ą. Kai perdedame vieną porą, padidiname "kelintas" kintamąjį vienetu. Jei kelintas pasiekia limitą - ciklą "breakiname", naudodami break komandą. </li>
                        <li>Nusinuliname kintamąjį. <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot62.jpg" alt="Kodo foto"></div></span></li>
                        <li>Sukame for-each ciklą. Kad tą padaryti rašome "iter", spaudžiame enter ir tada pasirenkame entrySet() <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot63.jpg" alt="Kodo foto"></div></span></li>
                        <li>Pradžioje ciklo patikriname ar "kelintas" nepasiekė dar "limitas", jeigu pasiekė, tai tada ciklą breakiname, jeigu nepasiekė nieko nedarome (else'o nedarome) <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot64.jpg" alt="Kodo foto"></div></span></li>
                        <li>Taip pat, prieš ciklą dar susikuriame tuščią TreeMap'ą - į jį dėsime top pirmus elementus. <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot65.jpg" alt="Kodo foto"></div></span></li>
                        <li>Ciklo viduje, dedame po vieną elementą iš surikiuoto į tą naują TreeMap'ą bei po įdėjimo padidiname kelintas reikšmę vienetu. <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot66.jpg" alt="Kodo foto"></div></span></li>
                        <li>Grąžiname topElementai map'ą per return'ą. <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot67.jpg" alt="Kodo foto"></div></span></li>
                        <li>Galime išbandyti šią funkciją pagrindėje programoje: <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot68.jpg" alt="Kodo foto"></div></span></li>
                        <li>Kaip matote, išveda TOP 3 leidyklas, tačiau jas išveda ne pagal knygų kiekį. Taip yra dėl to, nes mes kūrėme naują TreeMap'ą funkcijoje ir tam TreeMap'ui nepadavėme palygintuvo, todėl nors ir tas map'as gaunas TOP 3 leidyklas, jis savo viduje jas susiorganizuoja pagal iš anksto nustatytus TreeMap'o nustatymus - pagal raktą. Tą ir galime pastebėti TOP 3 leidyklos yra išrikiuotos abėcėlės tvarka. Tačiau, norėdami, jog ir TOP leidyklas grąžintų pagal knygų kiekį, reikėtų funkcijoje susikurti Comparator objektą ir jį paduoti kuriant naująjį TreeMap. Tačiau, tas Comparator objektas turi gauti HashMap, o ne TreeMap, dėl to prisidėtų į parametrus dar vienas parametras - HashMap nesurikiuotosKnygos. <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot69.jpg" alt="Kodo foto"></div></span></li>
                        <li>Galiausiai, geriausia viską susidėti į vieną bendrą funkciją, kuri panaudotų abi tas atskiras funkcijas kartu. <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot70.jpg" alt="Kodo foto"></div></span></li>
                        <li>Kaip matome, to Comparator sukūrimas vis kartojasi tiek rikiavimo, tiek top išrinkimo funkcijose. Todėl, galime jį "iškelti", t.y. sukurti bendroje topLedyklųRadimo funkcijoje ir jį paduoti sekančioms dviem funkcijoms, kurias paleidžia ta bendroji. <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot71.jpg" alt="Kodo foto"></div></span></li>   
                        <li>Taip pat galima šią užduotį išspręsti viena ilga eilute, kuri naudoja esąmų funkcijų ir duomenų tipų grandines bei lambda funkcijas. Šias "vienos eilutės" komandas yra gan sunku užrašyti nežinant, jas dažniausiai rastume pavyzdžiuose arba Googlėje, tačiau dabar įdėsiu pavyzdį kaip buvo galima tai padaryti ir kiekvieną dalį trumpai paaiškinsiu. Jei mokėsite šią eilutę pasikoreguoti savo reikėms - tai labai puiku, nes ir pakoreguoti tinkamai tikrai yra darbo. <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-lecture1/screenshot72.jpg" alt="Kodo foto"></div></span></li>   
                        <li>Ši funkcija grąžina LinkedHashMap'ą - Linked, tai reiškia, kad pirma pora turi nuorodą į antrą porą, antra pora turi nuorodą į trečią porą ir t.t., todėl surikiavus map'ą jo rikiavimas išlieka ir toliau. </li>
                        <li>Šis vienas ilgas užrašymas yra išskaldytas į kelias eilutes. To daryti, jog veiktų nėra būtina, tačiau tai padeda lengviau skaityti kodą ir analizuoti.</li>      
                        <li>Pradžioje, susikuriame Map tipo kintamąjį ir jį pavadiname topLeid (arba bet kaip kitaip), sakome, kad jis yra lygu (rašome lygybę). Tas mūsų naujas kintamasis bus lygus visos šitos ilgos funkcijų grandinių rezultatui.</li>    
                        <li>Funkcijų grandinė prasideda nuo to, jog paimame nesurikiuotą dažnumo Knygų map'ą (kiekKnyguLediykla) ir paimame jo poras (entrySet(), kadangi jei tik raktus tai keySet(), jei tik reikšmes tai valueSet()) ir įdedame jas į "stream'ą", streamas yra tokia speciali klasė, kuri skirt apdoroti tam tikrus duomenis/medžiagą, dažnai gali būti naudojamas duomenų konvertavime į kitą duomenų tipą. Taigi nesurikiuoto map'o konvertavimą į stream'ą uržašėme su <code class="language-java">kiekKnyguLediykla.entrySet().stream()</code></li>       
                        <li>Toliau, dedame vis tašką, kadangi dedami tašką vis nusakome, kad tolimesnės funkcijos yra atliekamos prieš tai esančiam objektui. Kaip kad pvz., kai mes arrayList.add() darome, tai pasakome, kad add() į arrayList objektą arba kaip mes darėme su map.put(), tai nusako, kad puttint į map'ą. Taip ir šioje funkcijų grandinėje viskas eina iš eilės ir nusako sekantys žingsniai, jog tą daryti prieš tai esnačiam objektui. Taigi, nors ir pas mus yra pilna taškų, tačiau užrašas <code class="language-java">kiekKnyguLediykla.entrySet().stream()</code> reiškia, jog tai yra Map paverstas į Stream, o kitaip sakant tai yra tiesiog Stream objektas, kuriame yra mūsų leidyklos. Toliau, po taško sakome ką daryti tam objektui. Toks principas galioje VISOJE JAVOJE, perpratus jį - persipranta didelė Javos dalis.</li> 
                        <li>Taigi, toliau Stream objektui naudojame <code class="language-java">sorted()</code> funkciją. Tai reiškia, jog paimame Stream objektą ir jį surikiuojame. Tad dabartinis užrašas <code class="language-java">kiekKnyguLediykla.entrySet().stream().sorted()</code> grąžina Stream surikiuotą objektą pagal sorted() funkciją.</li>
                        <li>Tačiau, mums paprastas sorted() rikiavimas netinka. Visų pirma, rikiaivimas bus didėjančia tvarka, o mum reikia top leidyklų, todėl į sorted() skliaustelius turime paduoti parametrus kaip rikiuoti. Kodėl būtent į sorted skliaustelius? Kadangi tai yra parametrai skirti sorted() funkcijai, o ne pvz. funkcijai, kuri verčia map į stream'ą. Šie parametrai būtent nusakys kaip rikiuoti, o ne kaip versti. Nors ir viskas atrodo kaip didelė krūva skliaustų ir užrašų, tačiau viskas turi savo eiliškumą bei vietą. Taigi į sorted() skliaustus sakome, jog norime rikiuoti mažėjančia tvarka. Tai padarome, paduodame Collection.reverseOrder() parametrą. Ir dabar jau turime tokį užrašą: <code class="language-java">kiekKnyguLeidykla.entrySet().stream().sorted(Collections.reverseOrder())</code></li>
                        <li>Taigi, dabar jau kaip ir turėtume rikiavimą, tačiau jeigu išbandytume, tikriausiai gautumėte error'ą, kadangi rikiavimo funkcija nežino pagal ką rikiuoti. Jei tai būtų tiesiog skaičių masyvas, tai ji juos paimtų ir surikiuotų, tačiau dabar yra Stream'as, kuriame yra Map'o Poros. Norint rikiuoti Map'o Poras, reikia pasakyti pagal ką jas rikiuojame - pagal key ar pagal value? Todėl į reverseOrder() skliaustus įrašome, jog rikiuojame pagal reikšmę. Ir visas didelis užrašas gaunasi, jog pakeičiame map'ą į streamą, tą streamą paimame ir surikiuojame didėjančia tvarka pagal stream'o elementų value, o ne key. Visas užrašymas gaunasi: <code class="language-java">kiekKnyguLeidykla.entrySet().stream().sorted(Collections.reverseOrder(Map.Entry.comparingByValue()))</code></li>
                        <li>Taigi, dabartinis mūsų rezultatas jau grąžintų surikiuotą Stream'ą. Vienintelės problemos, jog grąžintų dar vis visus elementus, o ne tik top kelis bei... dar mes vis turime Stream objektą, o norime Map objekto.</li>
                        <li>Taigi, toliau, po rikiavimo galime sakyti, jog mums nereikia visų Stream elementų, o norime tik tai kelių pradinių. Stream objektai turi specialą funkciją limit(), kuri grąžina tik tai kelis pirmus elementus. Ir čia svarbu yra eiliškumas, kadangi, jei mes limit() būtume pritaikinėję Stream objektui PRIEŠ sorted() (rikiavimą), tai tokiu atveju paimtų tris pirmus Stream'o elementus ir juos surikiuotų tarpusavyje ir grąžintų kaip TOP 3. Žinoma, mes norime ne to, todėl iš pradžių rikiavome, o dabar gautą rezultatą iš rikiavimo mes "limituojame", tad visas užrašas dabar jau gaunasi <code class="language-java">kiekKnyguLeidykla.entrySet().stream().sorted(Collections.reverseOrder(Map.Entry.comparingByValue()).limit(3))</code></li>
                        <li>Žinoma į limit skliaustelius reikia įrašyti kiek norėtume TOP.</li>
                        <li>Kadangi, norime ne Stream objekto, o jį norime konvertuoti į Map objektą, tai Stream objektus reikia taip vadinama "collectinti", t.y. surinkti. Yra įvairių surinkimo metodų, yra ir surinkimo kintamųjų, bet mums reikia surinkti į Map'ą. Todėl sakome collect() ir skliausteliuose nurodysime su kokiais parametrais collectinti. O parametruose tai nurodome, jog naudosime Collections klasės toMap() static funkciją. Rašome Collections.toMap() ir dabar reikia toMap() funkcijos viduje nurodyti kokius parametrus naudoti, kitaip sakant kokiomis taisyklėmis dėlioti Stream elementus į Map objektą. Parametrų užrašymas šis yra specialus Map'ui, pirma sakome, jog gauname Key apibūdinimą iš Map klasės, tada Value apibūdinimą (<code class="language-java">Map.Entry::getKey, Map.Entry::getValue,</code>) tada su lambda funkcija nurodome, kad key ir value sudaro vieną poros objektą (<code class="language-java">(e1, e2) -> e1</code>) ir tada nurodome, jog šį collectinimą saugome į naują LinkedHashMap objektą (<code class="language-java">LinkedHashMap::new</code>)</li>


                        

                    </ul>

                    <pre> <code class="language-html">&#x3C;p&#x3E; yra pastraipos žymė</code></pre>
                </div>
            </div>
        </div>
    </div>
</body>
</html>