<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../assets/styles/styles.css">
    <link rel="stylesheet" href="../assets/styles/prism.css">
    <script src="../assets/scripts/prism.js"></script>
    <script src="../assets/scripts/script.js"></script>
    <title>Spring Boot projekto planas ir nurodymai. Žingsnis po žingsnį.</title>
</head>
<body>
    <div class="page-container">
        <div class="sidebar-menu" id="sidebarMenu">
            <img id="sidebarArrow" class="arrow" src="../assets/img/menu-arrow-right.jpg" alt="Rodyklė rodanti į dešinę pusę, skirta atidaryti šoniniam meniu">
            <div class="sidebar-menu-text bold-text">SPAUSKITE NORINT ATIDARYTI MENIU</div>
            <ul id="sidebarMenuList">
                <li><a href="#section1">Meniu sąrašas</a></li>
            </ul>
        </div>

        <div class="main-content">
            <div class="section">
                <div class="section-header">
                    <h3 id="section1">Spring boot konfiguracija</h3>
                </div>
                <div class="theory-text">
                    <li>Norint pradėti Java Spring Boot projektą reikia nueiti į http://start.spring.io</li>
                    <li>Atsidarusiame puslapyje reikia surašyti pavadinimus į laukelius kaip nurodyta paveikslėlyje: <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-spring-boot/screenshot1.jpg" alt="Kodo foto"></div></span></li>
                    <li>Toliau, dešinėje pusėje reikia spausti "ADD DEPENDENCIES..." ir pridėti dependencies, kurias naudosime. Šiam projektui reikės: Spring Web, Spring Data JPA. Taip pat reikėtų dar Thymeleaf ir Spring Security, bet jeigu juos įdėsime iš karto, tai projektas neveiks, kol nesukonfiguruosime Security bei neparuošime Thymeleaf template'ų. Todėl Spring Security ir Thymeleaf įdėjimą paliksime pabaigai. <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-spring-boot/screenshot2.jpg" alt="Kodo foto"></div></span></li>
                    <li><b>Spring Web</b> - yra skirtas bendrai visumai šio projekto: jis yra pagrindinis dalykas, kuris leidžia visoms kitoms mūsų projekto dalis "komunikuoti" tarpusavyje. <b>Spring Data JPA</b> - su juo galime patogiai kurtis duomenų bazės veiksmus ir duomenų bazės struktūras. Taip pat šis įrankis yra atsakingas ir už prisijungimą prie duomenų bazės. Jis gali ir sukurti lenteles duombazėje pagal klasių struktūrą bei sugeneruoti tam tikras bendrines gavimo užklausas, kaip kad pvz. findReceptasByPavadinimas(). Taip pat, kurių dar dabar nededame, bet naudosime vėliau projekte (bus nurodyta kada) <b>Thymeleaf</b> - jis leidžia kurti puslapio template (šablonus) naudojant html ir css bei tam tikrus parametrus leidžia įrašyti iš javos naudojant tam tikrą sintaksę (apie ją vėliau). <b>Spring Security</b> - įrankis puslapio saugumui. Su juo yra apdorojama autentifikacija, registracija, puslapių leidimas tik tam tikriem vartotojam bei ir slaptažodžių hashinimas (užkodavimas, jog įvykus duombazės duomenų nutėkejimui sltaptažodžiai vis vien būtų nežinomi, nes jie užšifruoti)</li>
                    <li>Spaudžiame "Generate..." ir parsisiunčiame projekto .zip failą. Jį išsiekstraktuojame ir įeiname į išekstraktuotą aplanką.</li>
                    <li>Jame atsidarome "pom.xml" failą (galima spausti du kartus, galima atidaryti per intellij programą) <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-spring-boot/screenshot3.jpg" alt="Kodo foto"></div></span></li>
                    <li>Jei intellij nėra parinkta kaip pirminė programa, tai atsidarusiame meniu pasirinkite "More apps..." ir pasirinkite intellij (jei jis neatsidarė, spauskit ant to failo dešinį pelės klavišą ir open with --> choose another app (nebent matote intellij) <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-spring-boot/screenshot4.jpg" alt="Kodo foto"></div></span></li>
                    <li>Spaudžiame Ok ir paleis mūsų naujai sugeneruotą projektą per intellij programą. Kai paleis, palaukite, kol viską sutvarkys, kadangi iš pradžių projekto failus rodys išmėtytai. Kai projektas pasikrauna (apačioj dešinėj nėra jokio krovimo juostų ir failų struktūra matoma), tai galima pradėti darbą. </li>
                    <li>Einame į src -> main -> java -> resources -> application.properties failą</li>
                    <li>Jame įrašome šias eilutes: <div class="spoiler">
                        <div class="spoiler-content">
                            <pre><code class="language-java">spring.datasource.url=jdbc:mysql://localhost:3306/programavimas5_spring_pamoka?serverTimezone=UTC&amp;characterEncoding=utf8
spring.datasource.username=root
spring.datasource.password=
spring.jpa.database-platform=org.hibernate.dialect.MySQL5InnoDBDialect
spring.jpa.hibernate.ddl-auto=update
                                
                            </code></pre>
                        </div>
                        <div class="spoiler-button">
                            <button></button>
                        </div>
                    </div></li>
                    <li><b>spring.datasource.url=jdbc:mysql://localhost:3306/programavimas5_spring_pamoka?serverTimezone=UTC&amp;characterEncoding=utf8</b> - jūsų nuoroda į jūsų duomenų bazę. Ką jums reikia pakeisti tai "programavimas5_spring_pamoka" į jūsų duombazės pavadinimą</li>
                    <li><b>spring.datasource.username=root</b> vardas. Pas jus jis toks pats.</li>
                    <li><b>spring.datasource.password=</b> - jūsų duombazės slaptažodis. Pas jus jis stoks pats.</li>
                    <li><b>spring.jpa.database-platform=org.hibernate.dialect.MySQL5InnoDBDialect</b> - nurodome JPA įrankiui kokią duomenų bazę naudojome ir kokią jos kalbą ir jos versiją. Jeigu naudotume H2 duombazę - čia reikėtų nurodyti H2, jeigu naudotume MariaDB duombazę - čia reikėtų nurodyti. Mes naudosime MySQL 5 su InnoDB varikliu.</li>
                    <li><b>spring.jpa.hibernate.ddl-auto=update</b> - ši eilutė nusako ar sukurti duomenų bazėje lenteles pagal entity klases, jeigu tokių lentelių dar nėra. Tai yra gerai nustatyti kaip "update", kai pradedame projektą, jog lenteles užpildytų automatiškai, tačiau jau turint veikiantį ir galutinį projektą šį nustatymą iš "update" reikėtų pakeisti į "none"</li>
                    <li>Kai surašysite projekto nustatymus, galima pabandyti paleisti projektą - įsitikinti, jog viskas iki šiol veikia. Projektą galite paleisti per šį failą: <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-spring-boot/screenshotexample9.jpg" alt="Kodo foto"></div></span></li>
                    <li>Paleidus programą pas mane, man parašė tokį errorą: <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-spring-boot/screenshot10.jpg" alt="Kodo foto"></div></span> Jis reiškia, jog nepavyko prisijungi prie duomenų bazės. Tai gali būti dėl kelių priežasčių: neįjungėte wamp serverio, neturite tokios duomenų bazės phpmyadmin'e, arba bloga jūsų nuoroda į duomenų bazę application.properties faile. Mano atveju - aš neturėjau tokios duomenų bazės phpmyadmin'e, tad sukūręs ją (tuščią be lentelių) paleidžiu programą dar kartą: <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-spring-boot/screenshot11.jpg" alt="Kodo foto"></div></span></li>
                </div>
            </div>


            <div class="section">
                <div class="section-header">
                    <h3 id="section2">Model package. Entity dalis</h3>
                </div>
                <div class="theory-text">
                    <li>projekto-pavadimimas package (jūsų bus tiesiog koks projekto pavadinimas) susikuriame model package <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-spring-boot/screenshot5.jpg" alt="Kodo foto"></div></span></li>
                    <li>Toliau, model package susikuriame du kitus package: entity ir repository <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-spring-boot/screenshot6.jpg" alt="Kodo foto"></div></span> <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-spring-boot/screenshot7.jpg" alt="Kodo foto"></div></span> JEIGU KURIANT REPOSITORY PACKAGE Į PACKAGE PAVADINIMĄ ĮRAŠO "entity" ŽODĮ, TAI JĮ TIESIOG IŠTRINKITE IR VIETOJ JO PARAŠYKITE "repository" - TAIP SUKURS "repository" package "model" viduje šalia "entity", o ne "entity" viduje <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-spring-boot/screenshot8.jpg" alt="Kodo foto"></div></span></li>
                    <li>Toliau, entity package'o viduje reikia kurtis java klases, kurios nusakytų "realius loginius objektus", tai pvz. kuriant parduotuvės projektą, tai būtų prekės, klientai, užsakymai, sandėliai, t.t.; kuriant valgyklos - meniu, receptai, klientai; filmų puslapio - filmai, klientai, komentarai; ir panašiai. Šiame pavyzdyje darysime receptų puslapį, tai bus receptai, ingredientai ir vartotojai.</li>
                    <li>Taigi, šiam pavyzdžiui naudojant receptai ir ingredientai klases, susikuriu receptas klasę.</li>
                    <li>Susirašau visus "paprastus" kintamuosius - tuos, kurie ir taip yra lentelės stulpeliai. Pavyzdžiui receptas LENTELĖ turi id, pavadinimą, nurodymus, kalorijosPer100g, kaina ir vartotojo_id. Taip pat ji turi sąryšį per papildomą sujungimo lentelę su Ingredientais. vartotojo_id taip pat yra "jungiamasi" stulpelis, kuris nurodo į vartotojo lentelę (foreign key referencing user table).</li>
                    <li>Tad Receptas klasėje iš pradžių galime susirašyti paprastus stulpelius (vartotojo_id netinka, nes jis foreign key, jį užrašysime kitaip). Tai turėtų atrodyti taip: <div class="spoiler">
                        <div class="spoiler-content">
                            <pre><code class="language-java">package lt.imones.puslapis.projektopavadinimas.model.entity;

public class Receptas {
    private long id;
    private String pavadinimas;
    private String nurodymai;
    private int kalorijosPer100g;
    private double kaina;
}

                            </code></pre>
                        </div>
                        <div class="spoiler-button">
                            <button></button>
                        </div>
                    </div></li>
                    <li>Toliau, prie id pažymime su @ ženklu, jog tai yra Id ir jog tai yra GeneratedValue(generuojama reikšmė). Taip pat prie GeneratedValue skliausteliuose prirašome kokia yra strategy. Ji turėtų būti IDENTITY, tai reiškia, jog naudoja duomenų bazės auto-increment funkciją. Tai padės išvengti problemų, kai bandysite pridėti kai kuriuos duomenis phpmyadmin, o kai kuriuos per javą. Dažnai, jei yra nenaudojamas phpmyadmin, tai būtų naudojama ir SEQUENCE arba AUTO strategy. <div class="spoiler">
                        <div class="spoiler-content">
                            <pre><code class="language-java">package lt.imones.puslapis.projektopavadinimas.model.entity;

import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;

public class Receptas {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private long id;
    private String pavadinimas;
    private String nurodymai;
    private int kalorijosPer100g;
    private double kaina;
}

                            </code></pre>
                        </div>
                        <div class="spoiler-button">
                            <button></button>
                        </div>
                    </div></li>
                    <li>Taip pat, galime pažymėti, jog ši klasė yra Entity klasė, su @Entity žymėjimu <div class="spoiler">
                        <div class="spoiler-content">
                            <pre><code class="language-java">package lt.imones.puslapis.projektopavadinimas.model.entity;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;

@Entity
public class Receptas {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private long id;
    private String pavadinimas;
    private String nurodymai;
    private int kalorijosPer100g;
    private double kaina;
}

                            </code></pre>
                        </div>
                        <div class="spoiler-button">
                            <button></button>
                        </div>
                    </div></li>
                    <li>Toliau, reikia susirašyti "specialius" kintamuosius, tai yra tuos, kurie bus susiję su kitais objektais. Pavyzdžiui receptas gali turėti kelis Ingredientas objektus - recepto ingredientus. Tai būtų Set'as, kuriame yra Ingredientas klasės objektai. Taip pat, Ingredientas gali būti keliuose skirtinguose receptuose. Panašiai kaip receptas gali būti keliuose meniu ir viename meniu gali būti keli receptai. Tokios klasės yra sujungtos Many-To-Many principu ir jas reikia aprašyti tokiu žymėjimu: <div class="spoiler">
                        <div class="spoiler-content">
                            <pre><code class="language-java">    @ManyToMany
@JoinTable(
        name = "sujungimas_receptas_ingredientas",
        joinColumns = @JoinColumn(name = "receptas_id"),
        inverseJoinColumns = @JoinColumn(name = "ingredientas_id"))
private Set&lt;Ingredientas&gt; receptoIngredientai;
                            </code></pre>
                        </div>
                        <div class="spoiler-button">
                            <button></button>
                        </div>
                    </div></li>
                    <li>name - tai sujungimo lentelės pavadinimas</li>
                    <li>joinColumns - tai koks yra receptų (šios klasės) jungiamajo stulpelio pavadinimas toje sujungimų lentelėje</li>
                    <li>inverseJoinColumns - tai koks yra kito stulpelio pavadinimas (to, kuris nurodo į kitą (šiuo atveju ingredientų) lentelę)</li>
                    <li>Toliau, jeigu yra Many-To-One jungtis, t.y. receptas gali turėti tik vieną vartotoją, bet vienas vartotojas gali turėti kelis vartotojus, tai recepto dalyje sukurtume paprastą kintamąjį, kuris yra Vartotojas klasė, o vartotojas klasėje sukursime Set'ą, kuriame yra Receptai (vartotojo receptai).</li>
                    <li>Tai aprašome taip: <div class="spoiler">
                        <div class="spoiler-content">
                            <pre><code class="language-java">    @ManyToOne
@JoinColumn(name = "vartotojas_id")
private Vartotojas receptoKurejas;
                            </code></pre>
                        </div>
                        <div class="spoiler-button">
                            <button></button>
                        </div>
                    </div></li>
                    <li>JoinColumn name dalyje pažymime kokss bus stulpelio pavadinimas, kuris nurodys į vartotoją, na o šiuo atveju jis bus vartotojas_id</li>
                    <li>Toliau, generuojame tuščią ir pilną konstruktorių (jei reikės kokių kitų, galima prisidėti vėliau). Generuojame getterius ir setterius bei toString() metodą.</li>
                    <li>P.S. Ingredientas ir Vartotojas turėtų būti raudoni, kadangi jūs dar jiems neturite sukurtų klasių.</li>
                    <li>Galutinis variantas turėtų atrodyti panašiai į:  <div class="spoiler">
                        <div class="spoiler-content">
                            <pre><code class="language-java">package lt.imones.puslapis.projektopavadinimas.model.entity;

import javax.persistence.*;
import java.util.ArrayList;
import java.util.Set;

@Entity
public class Receptas {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private long id;
    private String pavadinimas;
    private String nurodymai;
    private int kalorijosPer100g;
    private double kaina;

    @ManyToMany
    @JoinTable(
            name = "sujungimas_receptas_ingredientas",
            joinColumns = @JoinColumn(name = "receptas_id"),
            inverseJoinColumns = @JoinColumn(name = "ingredientas_id"))
    private Set&lt;Ingredientas&gt; receptoIngredientai;

    @ManyToOne
    @JoinColumn(name = "vartotojas_id")
    private Vartotojas receptoKurejas;

    public Receptas() {
    }

    public Receptas(long id, String pavadinimas, String nurodymai, int kalorijosPer100g, double kaina, Set&lt;Ingredientas&gt; receptoIngredientai, Vartotojas receptoKurejas) {
        this.id = id;
        this.pavadinimas = pavadinimas;
        this.nurodymai = nurodymai;
        this.kalorijosPer100g = kalorijosPer100g;
        this.kaina = kaina;
        this.receptoIngredientai = receptoIngredientai;
        this.receptoKurejas = receptoKurejas;
    }

    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    public String getPavadinimas() {
        return pavadinimas;
    }

    public void setPavadinimas(String pavadinimas) {
        this.pavadinimas = pavadinimas;
    }

    public String getNurodymai() {
        return nurodymai;
    }

    public void setNurodymai(String nurodymai) {
        this.nurodymai = nurodymai;
    }

    public int getKalorijosPer100g() {
        return kalorijosPer100g;
    }

    public void setKalorijosPer100g(int kalorijosPer100g) {
        this.kalorijosPer100g = kalorijosPer100g;
    }

    public double getKaina() {
        return kaina;
    }

    public void setKaina(double kaina) {
        this.kaina = kaina;
    }

    public Set&lt;Ingredientas&gt; getReceptoIngredientai() {
        return receptoIngredientai;
    }

    public void setReceptoIngredientai(Set&lt;Ingredientas&gt; receptoIngredientai) {
        this.receptoIngredientai = receptoIngredientai;
    }

    public Vartotojas getReceptoKurejas() {
        return receptoKurejas;
    }

    public void setReceptoKurejas(Vartotojas receptoKurejas) {
        this.receptoKurejas = receptoKurejas;
    }

    @Override
    public String toString() {
        return "Receptas{" +
                "id=" + id +
                ", pavadinimas='" + pavadinimas + '\'' +
                ", nurodymai='" + nurodymai + '\'' +
                ", kalorijosPer100g=" + kalorijosPer100g +
                ", kaina=" + kaina +
                ", receptoIngredientai=" + receptoIngredientai +
                ", receptoKurejas=" + receptoKurejas +
                '}';
    }
}

                            </code></pre>
                        </div>
                        <div class="spoiler-button">
                            <button></button>
                        </div>
                    </div></li>
                    <li>Dabar kuriame Ingredientas klasę</li>
                    <li>Pradedame vėlgi nuo paprastų kintamųjų, t.y.: id, pavadinimas, kalorijosPer100g, kaina. Jam taip pat galima nustatyti, jog jis turi "specialų" sujungimo kintamąjį Set'ą receptų, kuris nurodytų, kuriuose receptuose yra ingredientas. Tačiau, tai gali būti gan didelis skaičius ir tai galime palikti atskirai funkcijai, kuri gal grąžintų tarkim tik po 25 arba 50 receptų, kuriuosse yra šis ingredientas (kadangi visų dažniausiai iš karto nereiki, galima grąžinti gabalais, pvz. 25 pirmų, 25 antrų, 25 trečių. Dažniausiai užtenka kelių "gabalų", jog "patenkinti" vartotojo paieškos rezultatus, o teoriškai gali būti ir šimtas tūksstančių receptų, kuriuose yra kažkoks ingredientas, tad grąžinti visus dėl pirmų kelių "gabalų" būtų neefektyvu. Kita "medalio pusė", tai jog kiekvieną kartą norint grąžinti "gabalą" reikia iš naujo kreiptis į duomenų bazę su užklausa - tai apkrauna duomenų bazę, todėl kai kuriuos kintamuosius, kaip kad pvz. receptoIngredientus norėtume gauti iš karto, nes jų gali būti ir daugiau nei 25, bet tikrai nebus daugiau nei 100, tad neapsimoka dėl kelių papildomų daryti papildomus kvietimus į duombazę - dėl to Receptas klasėje susikūrėme Set'ą receptoIngredientai, o Ingredientas klasėje nėra būtina susikurti Set'o receptų, tačiau, jei tai padarytumėte, tai nebūtų didelė klaida - o tą daryti visiškai identiškai kaip ir Recptas klasėje.</li>
                    <li>Taigi Ingredientas klasės pradžia turėtų atrodyti taip: <div class="spoiler">
                        <div class="spoiler-content">
                            <pre><code class="language-java">package lt.imones.puslapis.projektopavadinimas.model.entity;

import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;

@Entity
public class Ingredientas {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private long id;
    private String pavadinimas;
    private int kalorijosPer100g;
    private double kaina;
    
}
                            </code></pre>
                        </div>
                        <div class="spoiler-button">
                            <button></button>
                        </div>
                    </div></li>
                    <li>Toliau, generuojame konstruktorius. Getterius ir setterius. toString() metodą ir galiausiai klasė turėtų atrodyti štai taip: <div class="spoiler">
                        <div class="spoiler-content">
                            <pre><code class="language-java">package lt.imones.puslapis.projektopavadinimas.model.entity;

import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;

@Entity
public class Ingredientas {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private long id;
    private String pavadinimas;
    private int kalorijosPer100g;
    private double kaina;

    public Ingredientas() {
    }

    public Ingredientas(long id, String pavadinimas, int kalorijosPer100g, double kaina) {
        this.id = id;
        this.pavadinimas = pavadinimas;
        this.kalorijosPer100g = kalorijosPer100g;
        this.kaina = kaina;
    }

    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    public String getPavadinimas() {
        return pavadinimas;
    }

    public void setPavadinimas(String pavadinimas) {
        this.pavadinimas = pavadinimas;
    }

    public int getKalorijosPer100g() {
        return kalorijosPer100g;
    }

    public void setKalorijosPer100g(int kalorijosPer100g) {
        this.kalorijosPer100g = kalorijosPer100g;
    }

    public double getKaina() {
        return kaina;
    }

    public void setKaina(double kaina) {
        this.kaina = kaina;
    }

    @Override
    public String toString() {
        return "Ingredientas{" +
                "id=" + id +
                ", pavadinimas='" + pavadinimas + '\'' +
                ", kalorijosPer100g=" + kalorijosPer100g +
                ", kaina=" + kaina +
                '}';
    }
}


                            </code></pre>
                        </div>
                        <div class="spoiler-button">
                            <button></button>
                        </div>
                    </div></li>
                    <li>Sekantis etapas yra sukurti Vartotojas entity klasę. Vartotojas turės tokius "paprastus" kintamuosius kaip id, username, passsword. <div class="spoiler">
                        <div class="spoiler-content">
                            <pre><code class="language-java">package lt.imones.puslapis.projektopavadinimas.model.entity;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;

@Entity
public class Vartotojas {
    @Id
    @GeneratedValue
    long id;
    String username;
    String passsword;
}

                            </code></pre>
                        </div>
                        <div class="spoiler-button">
                            <button></button>
                        </div>
                    </div></li>
                    <li>Vartotojas gali turėti savo Receptas. Reiškiasi, jog Vartotojas klasė turi kažkaip būti sujungta su Receptas klase. Kadangi vartotojas tikriausiai receptų turės nedaugt (max gal iki 100 arba 1000), tai juos visuss galime saugoti Set'e kaip kintamąjį. <div class="spoiler">
                        <div class="spoiler-content">
                            <pre><code class="language-java">    @OneToMany(mappedBy = "receptoKurejas")
                                Set&lt;Receptas&gt; vartotojoReceptai;
                            </code></pre>
                        </div>
                        <div class="spoiler-button">
                            <button></button>
                        </div>
                    </div></li>
                    <li>Rašome OneToMany, kadangi vienas Vartotojas gali turėti daug receptų, tačiau receptas gali turėti tik vieną vartotoją. Toliau, rašome pagal kurį kintamąjį yra "sumappintas", tai šiuo atveju tiesiog įrašome iš šio sąryšio ManyToOne klasės kintamojo pavadinimą. Paprastesniais žodžiais: kadangi vartotojas connectina su receptas klase OneToMany ir receptas klasėje turime kintamąjį "Vartotojas receptoKurejas", tai reikia tiesiog nurodyti, kad tas kintamasis mappina būtent su šita klase.</li>
                    <li>Toliau, kuriame konstruktorius, getterius ir setterius ir toString() metodą. <div class="spoiler">
                        <div class="spoiler-content">
                            <pre><code class="language-java">package lt.imones.puslapis.projektopavadinimas.model.entity;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.OneToMany;
import java.util.Set;

@Entity
public class Vartotojas {
    @Id
    @GeneratedValue
    long id;
    String username;
    String passsword;

    @OneToMany(mappedBy = "receptoKurejas")
    Set&lt;Receptas&gt; vartotojoReceptai;

    public Vartotojas() {
    }

    public Vartotojas(long id, String username, String passsword, Set&lt;Receptas&gt; vartotojoReceptai) {
        this.id = id;
        this.username = username;
        this.passsword = passsword;
        this.vartotojoReceptai = vartotojoReceptai;
    }

    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPasssword() {
        return passsword;
    }

    public void setPasssword(String passsword) {
        this.passsword = passsword;
    }

    public Set&lt;Receptas&gt; getVartotojoReceptai() {
        return vartotojoReceptai;
    }

    public void setVartotojoReceptai(Set&lt;Receptas&gt; vartotojoReceptai) {
        this.vartotojoReceptai = vartotojoReceptai;
    }

    @Override
    public String toString() {
        return "Vartotojas{" +
                "id=" + id +
                ", username='" + username + '\'' +
                ", passsword='" + passsword + '\'' +
                ", vartotojoReceptai=" + vartotojoReceptai +
                '}';
    }
}

                            </code></pre>
                        </div>
                        <div class="spoiler-button">
                            <button></button>
                        </div>
                    </div></li>
                    <li>Proekto struktūra turėtų atrodyti štai taip: <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-spring-boot/screenshot12.jpg" alt="Kodo foto"></div></span></li>
                    <li>Kai paleidžiame programą, turėtume matyti (jei yra nustatyta spring.jpa.hibernate.ddl-auto=update) kaip sukuria mūsų duomenų bazių lentelių struktūrą (galima pasižiūrėti phpmyadmine) <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-spring-boot/screenshot13.jpg" alt="Kodo foto"></div></span></li>
                    <li>Jei paleidus programą neišmetė jokių klaidų <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-spring-boot/screenshot13.jpg" alt="Kodo foto"></div></span> ir phpmyadmine susikūrė lentelės (jei jos nebuvo sukurtos prieš tai) <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-spring-boot/screenshot14.jpg" alt="Kodo foto"></div></span></li>
                    <li>Jei viskas pasileido ir susikūrė: padarėte model.entity dalį.</li>
                </div>
            </div>

            <div class="section">
                <div class="section-header">
                    <h3 id="section1">Model package repository klasės.</h3>
                </div>
                <div class="theory-text">
                    <li>Kai susikūrėme visas (arba pradžiai reikalingas) Entity klases, reikia joms sukurti atitinkamus Repository interfeisus. Kadangi Entity klasėse saugojama "lentelių struktūra", o Repository interfeisuose saugojami veiksmai ir užklausos (gavimo, įdėjimo) su tomis lentelėmis.</li>
                    <li>Pradedame nuo ReceptasRepository interface dalies</li>
                    <li>Repository package dalyje kuriame ReceptasRepository interface (taip pat kaip klasę) <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-spring-boot/screenshot15.jpg" alt="Kodo foto"></div></span></li>
                    <li>Prirašome žymėjima, jog tai yra @Repository, bei pasakome, jog ištas Interface extendina JpaRepository - tai reiškia, jog šitas mūsų interface yra padarytas pagal JpaRepository principą. Toliau tarp mažiau ir daugiau ženklų įrašome klasę kuriai darome šią repository (Receptas) ir koks tos klasės id kintamojo tipas (long id, todėl Long, jeigu bus int id, tai bus Integer) <div class="spoiler">
                        <div class="spoiler-content">
                            <pre><code class="language-java">package lt.imones.puslapis.projektopavadinimas.model.repository;

import lt.imones.puslapis.projektopavadinimas.model.entity.Receptas;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface ReceptasRepository  extends JpaRepository&lt;Receptas, Long&gt; {
    
}

                            </code></pre>
                        </div>
                        <div class="spoiler-button">
                            <button></button>
                        </div>
                    </div></li>
                    <li>Kai turime pradžią, galime pradėti "generuoti" metodus. Metodų generavimas yra paremtas tiesisog metodo vardo ir parametrų užrašymu. Yra tam tikri šablonai pagal kuriuos sukūrę metodo pavadinimą mes jau turėsime veikiantį metodą. Apie juos galite pasiskaityti išsamiau čia: https://docs.spring.io/spring-data/jpa/docs/1.5.0.RELEASE/reference/html/jpa.repositories.html  </li>
                    <li>Trumpai apibendrinant, jeigu reikia kažką gauti išduomenų bazės: iš pradžių reikia pagalvoti ar gausim kelis ar tik vieną objektą. Pavyzdžiui, jei reikia rasti receptuos nuo 5 iki 10 eurų, tai gausime kelis receptus, todėl tai turėtų grąinti List&lt;Receptass&gt;, o jeigu pavyzdžiui reikia grąžinti brangiausią receptą - tai reikėtų grąžinti tik vieną receptą, todėl grąžins vieną Receptas klasės objektą. Kai nusprendėte ką grąžins, pradėkite funkcijos užrašą nuo duomenų tipo (tai arba list arba paprastas objektas) ir toliau pradedame konstruoti pavadinimą. Pradedame nuo žodžio "find", kuris reiškia rasti. Toliau rašome "By", kuris reiškia pagal. Toliau turime įrašyti stulpelio pavadinimą pagal kurį ieškotume, tai jeigu ieškotume recepto pagal pavadinimą rašytume findByPavadinimas(), jeigu ieškotume pagal id, rašytume findById(). Toliau, reikia kažką paduoti metodui per parametrus. Kadangi, kaip jis gali ieškoti recepto, jeigu jis negaus to recepto pavadinimo. Todėl galutinis užrašas turėtų atrodyti: Receptas findByPavadinimas(String pavadinimas). Jeigu reikėtų ieškoti receptų tam tikram intervale galima naudoti Between raktažodį (jis yra tame puslapyje, kur surašyti visi) ir taip galime užrašyti metodą: List&lt;Receptas&gt; findByKainaBetween(double pradineKaina, double galutineKaina)</li>
                    <li>Taigi gavimo funkcijų (pagal pavadinimą ir pagal tarp kainų tam tikrų) užrašymas turėtų atrodyti štai taip: <div class="spoiler">
                        <div class="spoiler-content">
                            <pre><code class="language-java">package lt.imones.puslapis.projektopavadinimas.model.repository;

import lt.imones.puslapis.projektopavadinimas.model.entity.Receptas;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface ReceptasRepository  extends JpaRepository&lt;Receptas, Long&gt; {

    Receptas findByPavadinimas(String pavadinimas);

    List&lt;Receptas&gt; findByKainaBetween(double pradineKaina, double galutineKaina);

}

                            </code></pre>
                        </div>
                        <div class="spoiler-button">
                            <button></button>
                        </div>
                    </div> </li>

                </div>
            </div>
        </div>
    </div>
</body>
</html>