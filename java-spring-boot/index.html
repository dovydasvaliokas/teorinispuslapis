<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../assets/styles/styles.css">
    <link rel="stylesheet" href="../assets/styles/prism.css">
    <script src="../assets/scripts/prism.js"></script>
    <script src="../assets/scripts/script.js"></script>
    <title>Spring Boot projekto planas ir nurodymai. Žingsnis po žingsnį.</title>
</head>
<body>
    <div class="page-container">
        <div class="sidebar-menu" id="sidebarMenu">
            <img id="sidebarArrow" class="arrow" src="../assets/img/menu-arrow-right.jpg" alt="Rodyklė rodanti į dešinę pusę, skirta atidaryti šoniniam meniu">
            <div class="sidebar-menu-text bold-text">SPAUSKITE NORINT ATIDARYTI MENIU</div>
            <ul id="sidebarMenuList">
                <li><a href="#section1">Meniu sąrašas</a></li>
            </ul>
        </div>

        <div class="main-content">
            <div class="section">
                <div class="section-header">
                    <h3 id="section1">Spring boot konfiguracija</h3>
                </div>
                <div class="theory-text">
                    <li>Norint pradėti Java Spring Boot projektą reikia nueiti į http://start.spring.io</li>
                    <li>Atsidarusiame puslapyje reikia surašyti pavadinimus į laukelius kaip nurodyta paveikslėlyje: <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-spring-boot/screenshot1.jpg" alt="Kodo foto"></div></span></li>
                    <li>Toliau, dešinėje pusėje reikia spausti "ADD DEPENDENCIES..." ir pridėti dependencies, kurias naudosime. Šiam projektui reikės: Spring Web, Spring Data JPA. Taip pat reikėtų dar Thymeleaf ir Spring Security, bet jeigu juos įdėsime iš karto, tai projektas neveiks, kol nesukonfiguruosime Security bei neparuošime Thymeleaf template'ų. Todėl Spring Security ir Thymeleaf įdėjimą paliksime pabaigai. <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-spring-boot/screenshot2.jpg" alt="Kodo foto"></div></span></li>
                    <li><b>Spring Web</b> - yra skirtas bendrai visumai šio projekto: jis yra pagrindinis dalykas, kuris leidžia visoms kitoms mūsų projekto dalis "komunikuoti" tarpusavyje. <b>Spring Data JPA</b> - su juo galime patogiai kurtis duomenų bazės veiksmus ir duomenų bazės struktūras. Taip pat šis įrankis yra atsakingas ir už prisijungimą prie duomenų bazės. Jis gali ir sukurti lenteles duombazėje pagal klasių struktūrą bei sugeneruoti tam tikras bendrines gavimo užklausas, kaip kad pvz. findReceptasByPavadinimas(). Taip pat, kurių dar dabar nededame, bet naudosime vėliau projekte (bus nurodyta kada) <b>Thymeleaf</b> - jis leidžia kurti puslapio template (šablonus) naudojant html ir css bei tam tikrus parametrus leidžia įrašyti iš javos naudojant tam tikrą sintaksę (apie ją vėliau). <b>Spring Security</b> - įrankis puslapio saugumui. Su juo yra apdorojama autentifikacija, registracija, puslapių leidimas tik tam tikriem vartotojam bei ir slaptažodžių hashinimas (užkodavimas, jog įvykus duombazės duomenų nutėkejimui sltaptažodžiai vis vien būtų nežinomi, nes jie užšifruoti)</li>
                    <li>Spaudžiame "Generate..." ir parsisiunčiame projekto .zip failą. Jį išsiekstraktuojame ir įeiname į išekstraktuotą aplanką.</li>
                    <li>Jame atsidarome "pom.xml" failą (galima spausti du kartus, galima atidaryti per intellij programą) <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-spring-boot/screenshot3.jpg" alt="Kodo foto"></div></span></li>
                    <li>Jei intellij nėra parinkta kaip pirminė programa, tai atsidarusiame meniu pasirinkite "More apps..." ir pasirinkite intellij (jei jis neatsidarė, spauskit ant to failo dešinį pelės klavišą ir open with --> choose another app (nebent matote intellij) <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-spring-boot/screenshot4.jpg" alt="Kodo foto"></div></span></li>
                    <li>Spaudžiame Ok ir paleis mūsų naujai sugeneruotą projektą per intellij programą. Kai paleis, palaukite, kol viską sutvarkys, kadangi iš pradžių projekto failus rodys išmėtytai. Kai projektas pasikrauna (apačioj dešinėj nėra jokio krovimo juostų ir failų struktūra matoma), tai galima pradėti darbą. </li>
                    <li>Einame į src -> main -> java -> resources -> application.properties failą</li>
                    <li>Jame įrašome šias eilutes: <div class="spoiler">
                        <div class="spoiler-content">
                            <pre><code class="language-java">spring.datasource.url=jdbc:mysql://localhost:3306/programavimas5_spring_pamoka?serverTimezone=UTC&amp;characterEncoding=utf8
spring.datasource.username=root
spring.datasource.password=
spring.jpa.database-platform=org.hibernate.dialect.MySQL5InnoDBDialect
spring.jpa.hibernate.ddl-auto=update
                                
                            </code></pre>
                        </div>
                        <div class="spoiler-button">
                            <button></button>
                        </div>
                    </div></li>
                    <li><b>spring.datasource.url=jdbc:mysql://localhost:3306/programavimas5_spring_pamoka?serverTimezone=UTC&amp;characterEncoding=utf8</b> - jūsų nuoroda į jūsų duomenų bazę. Ką jums reikia pakeisti tai "programavimas5_spring_pamoka" į jūsų duombazės pavadinimą</li>
                    <li><b>spring.datasource.username=root</b> vardas. Pas jus jis toks pats.</li>
                    <li><b>spring.datasource.password=</b> - jūsų duombazės slaptažodis. Pas jus jis stoks pats.</li>
                    <li><b>spring.jpa.database-platform=org.hibernate.dialect.MySQL5InnoDBDialect</b> - nurodome JPA įrankiui kokią duomenų bazę naudojome ir kokią jos kalbą ir jos versiją. Jeigu naudotume H2 duombazę - čia reikėtų nurodyti H2, jeigu naudotume MariaDB duombazę - čia reikėtų nurodyti. Mes naudosime MySQL 5 su InnoDB varikliu.</li>
                    <li><b>spring.jpa.hibernate.ddl-auto=update</b> - ši eilutė nusako ar sukurti duomenų bazėje lenteles pagal entity klases, jeigu tokių lentelių dar nėra. Tai yra gerai nustatyti kaip "update", kai pradedame projektą, jog lenteles užpildytų automatiškai, tačiau jau turint veikiantį ir galutinį projektą šį nustatymą iš "update" reikėtų pakeisti į "none"</li>
                    <li>Kai surašysite projekto nustatymus, galima pabandyti paleisti projektą - įsitikinti, jog viskas iki šiol veikia. Projektą galite paleisti per šį failą: <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-spring-boot/screenshotexample9.jpg" alt="Kodo foto"></div></span></li>
                    <li>Paleidus programą pas mane, man parašė tokį errorą: <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-spring-boot/screenshot10.jpg" alt="Kodo foto"></div></span> Jis reiškia, jog nepavyko prisijungi prie duomenų bazės. Tai gali būti dėl kelių priežasčių: neįjungėte wamp serverio, neturite tokios duomenų bazės phpmyadmin'e, arba bloga jūsų nuoroda į duomenų bazę application.properties faile. Mano atveju - aš neturėjau tokios duomenų bazės phpmyadmin'e, tad sukūręs ją (tuščią be lentelių) paleidžiu programą dar kartą: <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-spring-boot/screenshot11.jpg" alt="Kodo foto"></div></span></li>
                </div>
            </div>


            <div class="section">
                <div class="section-header">
                    <h3 id="section2">Model package. Entity dalis</h3>
                </div>
                <div class="theory-text">
                    <li>projekto-pavadimimas package (jūsų bus tiesiog koks projekto pavadinimas) susikuriame model package <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-spring-boot/screenshot5.jpg" alt="Kodo foto"></div></span></li>
                    <li>Toliau, model package susikuriame du kitus package: entity ir repository <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-spring-boot/screenshot6.jpg" alt="Kodo foto"></div></span> <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-spring-boot/screenshot7.jpg" alt="Kodo foto"></div></span> JEIGU KURIANT REPOSITORY PACKAGE Į PACKAGE PAVADINIMĄ ĮRAŠO "entity" ŽODĮ, TAI JĮ TIESIOG IŠTRINKITE IR VIETOJ JO PARAŠYKITE "repository" - TAIP SUKURS "repository" package "model" viduje šalia "entity", o ne "entity" viduje <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-spring-boot/screenshot8.jpg" alt="Kodo foto"></div></span></li>
                    <li>Toliau, entity package'o viduje reikia kurtis java klases, kurios nusakytų "realius loginius objektus", tai pvz. kuriant parduotuvės projektą, tai būtų prekės, klientai, užsakymai, sandėliai, t.t.; kuriant valgyklos - meniu, receptai, klientai; filmų puslapio - filmai, klientai, komentarai; ir panašiai. Šiame pavyzdyje darysime receptų puslapį, tai bus receptai, ingredientai ir vartotojai.</li>
                    <li>Taigi, šiam pavyzdžiui naudojant receptai ir ingredientai klases, susikuriu receptas klasę.</li>
                    <li>Susirašau visus "paprastus" kintamuosius - tuos, kurie ir taip yra lentelės stulpeliai. Pavyzdžiui receptas LENTELĖ turi id, pavadinimą, nurodymus, kalorijosPer100g, kaina ir vartotojo_id. Taip pat ji turi sąryšį per papildomą sujungimo lentelę su Ingredientais. vartotojo_id taip pat yra "jungiamasi" stulpelis, kuris nurodo į vartotojo lentelę (foreign key referencing user table).</li>
                    <li>Tad Receptas klasėje iš pradžių galime susirašyti paprastus stulpelius (vartotojo_id netinka, nes jis foreign key, jį užrašysime kitaip). Tai turėtų atrodyti taip: <div class="spoiler">
                        <div class="spoiler-content">
                            <pre><code class="language-java">package lt.imones.puslapis.projektopavadinimas.model.entity;

public class Receptas {
    private long id;
    private String pavadinimas;
    private String nurodymai;
    private int kalorijosPer100g;
    private double kaina;
}

                            </code></pre>
                        </div>
                        <div class="spoiler-button">
                            <button></button>
                        </div>
                    </div></li>
                    <li>Toliau, prie id pažymime su @ ženklu, jog tai yra Id ir jog tai yra GeneratedValue(generuojama reikšmė). Taip pat prie GeneratedValue skliausteliuose prirašome kokia yra strategy. Ji turėtų būti IDENTITY, tai reiškia, jog naudoja duomenų bazės auto-increment funkciją. Tai padės išvengti problemų, kai bandysite pridėti kai kuriuos duomenis phpmyadmin, o kai kuriuos per javą. Dažnai, jei yra nenaudojamas phpmyadmin, tai būtų naudojama ir SEQUENCE arba AUTO strategy. <div class="spoiler">
                        <div class="spoiler-content">
                            <pre><code class="language-java">package lt.imones.puslapis.projektopavadinimas.model.entity;

import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;

public class Receptas {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private long id;
    private String pavadinimas;
    private String nurodymai;
    private int kalorijosPer100g;
    private double kaina;
}

                            </code></pre>
                        </div>
                        <div class="spoiler-button">
                            <button></button>
                        </div>
                    </div></li>
                    <li>Taip pat, galime pažymėti, jog ši klasė yra Entity klasė, su @Entity žymėjimu <div class="spoiler">
                        <div class="spoiler-content">
                            <pre><code class="language-java">package lt.imones.puslapis.projektopavadinimas.model.entity;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;

@Entity
public class Receptas {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private long id;
    private String pavadinimas;
    private String nurodymai;
    private int kalorijosPer100g;
    private double kaina;
}

                            </code></pre>
                        </div>
                        <div class="spoiler-button">
                            <button></button>
                        </div>
                    </div></li>
                    <li>Toliau, reikia susirašyti "specialius" kintamuosius, tai yra tuos, kurie bus susiję su kitais objektais. Pavyzdžiui receptas gali turėti kelis Ingredientas objektus - recepto ingredientus. Tai būtų Set'as, kuriame yra Ingredientas klasės objektai. Taip pat, Ingredientas gali būti keliuose skirtinguose receptuose. Panašiai kaip receptas gali būti keliuose meniu ir viename meniu gali būti keli receptai. Tokios klasės yra sujungtos Many-To-Many principu ir jas reikia aprašyti tokiu žymėjimu: <div class="spoiler">
                        <div class="spoiler-content">
                            <pre><code class="language-java">    @ManyToMany
@JoinTable(
        name = "sujungimas_receptas_ingredientas",
        joinColumns = @JoinColumn(name = "receptas_id"),
        inverseJoinColumns = @JoinColumn(name = "ingredientas_id"))
private Set&lt;Ingredientas&gt; receptoIngredientai;
                            </code></pre>
                        </div>
                        <div class="spoiler-button">
                            <button></button>
                        </div>
                    </div></li>
                    <li>name - tai sujungimo lentelės pavadinimas</li>
                    <li>joinColumns - tai koks yra receptų (šios klasės) jungiamajo stulpelio pavadinimas toje sujungimų lentelėje</li>
                    <li>inverseJoinColumns - tai koks yra kito stulpelio pavadinimas (to, kuris nurodo į kitą (šiuo atveju ingredientų) lentelę)</li>
                    <li>Toliau, jeigu yra Many-To-One jungtis, t.y. receptas gali turėti tik vieną vartotoją, bet vienas vartotojas gali turėti kelis vartotojus, tai recepto dalyje sukurtume paprastą kintamąjį, kuris yra Vartotojas klasė, o vartotojas klasėje sukursime Set'ą, kuriame yra Receptai (vartotojo receptai).</li>
                    <li>Tai aprašome taip: <div class="spoiler">
                        <div class="spoiler-content">
                            <pre><code class="language-java">    @ManyToOne
@JoinColumn(name = "vartotojas_id")
private Vartotojas receptoKurejas;
                            </code></pre>
                        </div>
                        <div class="spoiler-button">
                            <button></button>
                        </div>
                    </div></li>
                    <li>JoinColumn name dalyje pažymime kokss bus stulpelio pavadinimas, kuris nurodys į vartotoją, na o šiuo atveju jis bus vartotojas_id</li>
                    <li>Toliau, generuojame tuščią ir pilną konstruktorių (jei reikės kokių kitų, galima prisidėti vėliau). Generuojame getterius ir setterius bei toString() metodą.</li>
                    <li>P.S. Ingredientas ir Vartotojas turėtų būti raudoni, kadangi jūs dar jiems neturite sukurtų klasių.</li>
                    <li>Galutinis variantas turėtų atrodyti panašiai į:  <div class="spoiler">
                        <div class="spoiler-content">
                            <pre><code class="language-java">package lt.imones.puslapis.projektopavadinimas.model.entity;

import javax.persistence.*;
import java.util.ArrayList;
import java.util.Set;

@Entity
public class Receptas {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private long id;
    private String pavadinimas;
    private String nurodymai;
    private int kalorijosPer100g;
    private double kaina;

    @ManyToMany
    @JoinTable(
            name = "sujungimas_receptas_ingredientas",
            joinColumns = @JoinColumn(name = "receptas_id"),
            inverseJoinColumns = @JoinColumn(name = "ingredientas_id"))
    private Set&lt;Ingredientas&gt; receptoIngredientai;

    @ManyToOne
    @JoinColumn(name = "vartotojas_id")
    private Vartotojas receptoKurejas;

    public Receptas() {
    }

    public Receptas(long id, String pavadinimas, String nurodymai, int kalorijosPer100g, double kaina, Set&lt;Ingredientas&gt; receptoIngredientai, Vartotojas receptoKurejas) {
        this.id = id;
        this.pavadinimas = pavadinimas;
        this.nurodymai = nurodymai;
        this.kalorijosPer100g = kalorijosPer100g;
        this.kaina = kaina;
        this.receptoIngredientai = receptoIngredientai;
        this.receptoKurejas = receptoKurejas;
    }

    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    public String getPavadinimas() {
        return pavadinimas;
    }

    public void setPavadinimas(String pavadinimas) {
        this.pavadinimas = pavadinimas;
    }

    public String getNurodymai() {
        return nurodymai;
    }

    public void setNurodymai(String nurodymai) {
        this.nurodymai = nurodymai;
    }

    public int getKalorijosPer100g() {
        return kalorijosPer100g;
    }

    public void setKalorijosPer100g(int kalorijosPer100g) {
        this.kalorijosPer100g = kalorijosPer100g;
    }

    public double getKaina() {
        return kaina;
    }

    public void setKaina(double kaina) {
        this.kaina = kaina;
    }

    public Set&lt;Ingredientas&gt; getReceptoIngredientai() {
        return receptoIngredientai;
    }

    public void setReceptoIngredientai(Set&lt;Ingredientas&gt; receptoIngredientai) {
        this.receptoIngredientai = receptoIngredientai;
    }

    public Vartotojas getReceptoKurejas() {
        return receptoKurejas;
    }

    public void setReceptoKurejas(Vartotojas receptoKurejas) {
        this.receptoKurejas = receptoKurejas;
    }

    @Override
    public String toString() {
        return "Receptas{" +
                "id=" + id +
                ", pavadinimas='" + pavadinimas + '\'' +
                ", nurodymai='" + nurodymai + '\'' +
                ", kalorijosPer100g=" + kalorijosPer100g +
                ", kaina=" + kaina +
                ", receptoIngredientai=" + receptoIngredientai +
                ", receptoKurejas=" + receptoKurejas +
                '}';
    }
}

                            </code></pre>
                        </div>
                        <div class="spoiler-button">
                            <button></button>
                        </div>
                    </div></li>
                    <li>Dabar kuriame Ingredientas klasę</li>
                    <li>Pradedame vėlgi nuo paprastų kintamųjų, t.y.: id, pavadinimas, kalorijosPer100g, kaina. Jam taip pat galima nustatyti, jog jis turi "specialų" sujungimo kintamąjį Set'ą receptų, kuris nurodytų, kuriuose receptuose yra ingredientas. Tačiau, tai gali būti gan didelis skaičius ir tai galime palikti atskirai funkcijai, kuri gal grąžintų tarkim tik po 25 arba 50 receptų, kuriuosse yra šis ingredientas (kadangi visų dažniausiai iš karto nereiki, galima grąžinti gabalais, pvz. 25 pirmų, 25 antrų, 25 trečių. Dažniausiai užtenka kelių "gabalų", jog "patenkinti" vartotojo paieškos rezultatus, o teoriškai gali būti ir šimtas tūksstančių receptų, kuriuose yra kažkoks ingredientas, tad grąžinti visus dėl pirmų kelių "gabalų" būtų neefektyvu. Kita "medalio pusė", tai jog kiekvieną kartą norint grąžinti "gabalą" reikia iš naujo kreiptis į duomenų bazę su užklausa - tai apkrauna duomenų bazę, todėl kai kuriuos kintamuosius, kaip kad pvz. receptoIngredientus norėtume gauti iš karto, nes jų gali būti ir daugiau nei 25, bet tikrai nebus daugiau nei 100, tad neapsimoka dėl kelių papildomų daryti papildomus kvietimus į duombazę - dėl to Receptas klasėje susikūrėme Set'ą receptoIngredientai, o Ingredientas klasėje nėra būtina susikurti Set'o receptų, tačiau, jei tai padarytumėte, tai nebūtų didelė klaida - o tą daryti visiškai identiškai kaip ir Recptas klasėje.</li>
                    <li>Taigi Ingredientas klasės pradžia turėtų atrodyti taip: <div class="spoiler">
                        <div class="spoiler-content">
                            <pre><code class="language-java">package lt.imones.puslapis.projektopavadinimas.model.entity;

import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;

@Entity
public class Ingredientas {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private long id;
    private String pavadinimas;
    private int kalorijosPer100g;
    private double kaina;
    
}
                            </code></pre>
                        </div>
                        <div class="spoiler-button">
                            <button></button>
                        </div>
                    </div></li>
                    <li>Toliau, generuojame konstruktorius. Getterius ir setterius. toString() metodą ir galiausiai klasė turėtų atrodyti štai taip: <div class="spoiler">
                        <div class="spoiler-content">
                            <pre><code class="language-java">package lt.imones.puslapis.projektopavadinimas.model.entity;

import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;

@Entity
public class Ingredientas {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private long id;
    private String pavadinimas;
    private int kalorijosPer100g;
    private double kaina;

    public Ingredientas() {
    }

    public Ingredientas(long id, String pavadinimas, int kalorijosPer100g, double kaina) {
        this.id = id;
        this.pavadinimas = pavadinimas;
        this.kalorijosPer100g = kalorijosPer100g;
        this.kaina = kaina;
    }

    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    public String getPavadinimas() {
        return pavadinimas;
    }

    public void setPavadinimas(String pavadinimas) {
        this.pavadinimas = pavadinimas;
    }

    public int getKalorijosPer100g() {
        return kalorijosPer100g;
    }

    public void setKalorijosPer100g(int kalorijosPer100g) {
        this.kalorijosPer100g = kalorijosPer100g;
    }

    public double getKaina() {
        return kaina;
    }

    public void setKaina(double kaina) {
        this.kaina = kaina;
    }

    @Override
    public String toString() {
        return "Ingredientas{" +
                "id=" + id +
                ", pavadinimas='" + pavadinimas + '\'' +
                ", kalorijosPer100g=" + kalorijosPer100g +
                ", kaina=" + kaina +
                '}';
    }
}


                            </code></pre>
                        </div>
                        <div class="spoiler-button">
                            <button></button>
                        </div>
                    </div></li>
                    <li>Sekantis etapas yra sukurti Vartotojas entity klasę. Vartotojas turės tokius "paprastus" kintamuosius kaip id, username, passsword. <div class="spoiler">
                        <div class="spoiler-content">
                            <pre><code class="language-java">package lt.imones.puslapis.projektopavadinimas.model.entity;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;

@Entity
public class Vartotojas {
    @Id
    @GeneratedValue
    long id;
    String username;
    String passsword;
}

                            </code></pre>
                        </div>
                        <div class="spoiler-button">
                            <button></button>
                        </div>
                    </div></li>
                    <li>Vartotojas gali turėti savo Receptas. Reiškiasi, jog Vartotojas klasė turi kažkaip būti sujungta su Receptas klase. Kadangi vartotojas tikriausiai receptų turės nedaugt (max gal iki 100 arba 1000), tai juos visuss galime saugoti Set'e kaip kintamąjį. <div class="spoiler">
                        <div class="spoiler-content">
                            <pre><code class="language-java">    @OneToMany(mappedBy = "receptoKurejas")
                                Set&lt;Receptas&gt; vartotojoReceptai;
                            </code></pre>
                        </div>
                        <div class="spoiler-button">
                            <button></button>
                        </div>
                    </div></li>
                    <li>Rašome OneToMany, kadangi vienas Vartotojas gali turėti daug receptų, tačiau receptas gali turėti tik vieną vartotoją. Toliau, rašome pagal kurį kintamąjį yra "sumappintas", tai šiuo atveju tiesiog įrašome iš šio sąryšio ManyToOne klasės kintamojo pavadinimą. Paprastesniais žodžiais: kadangi vartotojas connectina su receptas klase OneToMany ir receptas klasėje turime kintamąjį "Vartotojas receptoKurejas", tai reikia tiesiog nurodyti, kad tas kintamasis mappina būtent su šita klase.</li>
                    <li>Toliau, kuriame konstruktorius, getterius ir setterius ir toString() metodą. <div class="spoiler">
                        <div class="spoiler-content">
                            <pre><code class="language-java">package lt.imones.puslapis.projektopavadinimas.model.entity;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.OneToMany;
import java.util.Set;

@Entity
public class Vartotojas {
    @Id
    @GeneratedValue
    long id;
    String username;
    String passsword;

    @OneToMany(mappedBy = "receptoKurejas")
    Set&lt;Receptas&gt; vartotojoReceptai;

    public Vartotojas() {
    }

    public Vartotojas(long id, String username, String passsword, Set&lt;Receptas&gt; vartotojoReceptai) {
        this.id = id;
        this.username = username;
        this.passsword = passsword;
        this.vartotojoReceptai = vartotojoReceptai;
    }

    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPasssword() {
        return passsword;
    }

    public void setPasssword(String passsword) {
        this.passsword = passsword;
    }

    public Set&lt;Receptas&gt; getVartotojoReceptai() {
        return vartotojoReceptai;
    }

    public void setVartotojoReceptai(Set&lt;Receptas&gt; vartotojoReceptai) {
        this.vartotojoReceptai = vartotojoReceptai;
    }

    @Override
    public String toString() {
        return "Vartotojas{" +
                "id=" + id +
                ", username='" + username + '\'' +
                ", passsword='" + passsword + '\'' +
                ", vartotojoReceptai=" + vartotojoReceptai +
                '}';
    }
}

                            </code></pre>
                        </div>
                        <div class="spoiler-button">
                            <button></button>
                        </div>
                    </div></li>
                    <li>Proekto struktūra turėtų atrodyti štai taip: <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-spring-boot/screenshot12.jpg" alt="Kodo foto"></div></span></li>
                    <li>Kai paleidžiame programą, turėtume matyti (jei yra nustatyta spring.jpa.hibernate.ddl-auto=update) kaip sukuria mūsų duomenų bazių lentelių struktūrą (galima pasižiūrėti phpmyadmine) <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-spring-boot/screenshot13.jpg" alt="Kodo foto"></div></span></li>
                    <li>Jei paleidus programą neišmetė jokių klaidų <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-spring-boot/screenshot13.jpg" alt="Kodo foto"></div></span> ir phpmyadmine susikūrė lentelės (jei jos nebuvo sukurtos prieš tai) <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-spring-boot/screenshot14.jpg" alt="Kodo foto"></div></span></li>
                    <li>Jei viskas pasileido ir susikūrė: padarėte model.entity dalį.</li>
                </div>
            </div>

            <div class="section">
                <div class="section-header">
                    <h3 id="section1">Model package repository klasės.</h3>
                    <h3 id="section1">Controller package ReceptasController klasė</h3>
                </div>
                <div class="theory-text">
                    <li>Kai susikūrėme visas (arba pradžiai reikalingas) Entity klases, reikia joms sukurti atitinkamus Repository interfeisus. Kadangi Entity klasėse saugojama "lentelių struktūra", o Repository interfeisuose saugojami veiksmai ir užklausos (gavimo, įdėjimo) su tomis lentelėmis.</li>
                    <li>Pradedame nuo ReceptasRepository interface dalies</li>
                    <li>Repository package dalyje kuriame ReceptasRepository interface (taip pat kaip klasę) <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-spring-boot/screenshot15.jpg" alt="Kodo foto"></div></span></li>
                    <li>Prirašome žymėjima, jog tai yra @Repository, bei pasakome, jog ištas Interface extendina JpaRepository - tai reiškia, jog šitas mūsų interface yra padarytas pagal JpaRepository principą. Toliau tarp mažiau ir daugiau ženklų įrašome klasę kuriai darome šią repository (Receptas) ir koks tos klasės id kintamojo tipas (long id, todėl Long, jeigu bus int id, tai bus Integer) <div class="spoiler">
                        <div class="spoiler-content">
                            <pre><code class="language-java">package lt.imones.puslapis.projektopavadinimas.model.repository;

import lt.imones.puslapis.projektopavadinimas.model.entity.Receptas;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface ReceptasRepository  extends JpaRepository&lt;Receptas, Long&gt; {

}

                            </code></pre>
                        </div>
                        <div class="spoiler-button">
                            <button></button>
                        </div>
                    </div></li>
                    <li>Kai turime pradžią, galime pradėti "generuoti" metodus. Metodų generavimas yra paremtas tiesisog metodo vardo ir parametrų užrašymu. Yra tam tikri šablonai pagal kuriuos sukūrę metodo pavadinimą mes jau turėsime veikiantį metodą. Apie juos galite pasiskaityti išsamiau čia: <a href="https://docs.spring.io/spring-data/jpa/docs/1.5.0.RELEASE/reference/html/jpa.repositories.html">https://docs.spring.io/spring-data/jpa/docs/1.5.0.RELEASE/reference/html/jpa.repositories.html</a>  </li>
                    <li>Trumpai apibendrinant, jeigu reikia kažką gauti išduomenų bazės: iš pradžių reikia pagalvoti ar gausim kelis ar tik vieną objektą. Pavyzdžiui, jei reikia rasti receptuos nuo 5 iki 10 eurų, tai gausime kelis receptus, todėl tai turėtų grąinti List&lt;Receptass&gt;, o jeigu pavyzdžiui reikia grąžinti brangiausią receptą - tai reikėtų grąžinti tik vieną receptą, todėl grąžins vieną Receptas klasės objektą. Kai nusprendėte ką grąžins, pradėkite funkcijos užrašą nuo duomenų tipo (tai arba list arba paprastas objektas) ir toliau pradedame konstruoti pavadinimą. Pradedame nuo žodžio "find", kuris reiškia rasti. Toliau rašome "By", kuris reiškia pagal. Toliau turime įrašyti stulpelio pavadinimą pagal kurį ieškotume, tai jeigu ieškotume recepto pagal pavadinimą rašytume findByPavadinimas(), jeigu ieškotume pagal id, rašytume findById(). Toliau, reikia kažką paduoti metodui per parametrus. Kadangi, kaip jis gali ieškoti recepto, jeigu jis negaus to recepto pavadinimo. Todėl galutinis užrašas turėtų atrodyti: Receptas findByPavadinimas(String pavadinimas). Jeigu reikėtų ieškoti receptų tam tikram intervale galima naudoti Between raktažodį (jis yra tame puslapyje, kur surašyti visi) ir taip galime užrašyti metodą: List&lt;Receptas&gt; findByKainaBetween(double pradineKaina, double galutineKaina)</li>
                    <li>Taigi gavimo funkcijų (pagal pavadinimą ir pagal tarp kainų tam tikrų) užrašymas turėtų atrodyti štai taip: <div class="spoiler">
                        <div class="spoiler-content">
                            <pre><code class="language-java">package lt.imones.puslapis.projektopavadinimas.model.repository;

import lt.imones.puslapis.projektopavadinimas.model.entity.Receptas;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface ReceptasRepository  extends JpaRepository&lt;Receptas, Long&gt; {

    Receptas findByPavadinimas(String pavadinimas);

    List&lt;Receptas&gt; findByKainaBetween(double pradineKaina, double galutineKaina);

}

                            </code></pre>
                        </div>
                        <div class="spoiler-button">
                            <button></button>
                        </div>
                    </div> </li>
                </div>
            </div>

            <div class="section">
                <div class="section-header">
                    <h3 id="section1">Controller package ReceptasController klasė</h3>
                </div>
                <div class="theory-text">
                    <li>Controller package dalyje susikuriame ReceptasController klasę. <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-spring-boot/screenshot16.jpg" alt="Kodo foto"></div></span></li>
                    <li>Pasižymime, jog ji yra @RestController klasė. Bei pasirašome patį pirmą TESTINĮ endpoint'ą ir jam metodą: tai parašysime, jog endpointas yra test/greeting ir padarysime, jog jis negauna jokių parametrų, bet tiesiog į naršyklės langą išvestų "šis puslapiss veikia". <div class="spoiler">
                        <div class="spoiler-content">
                            <pre><code class="language-java">package lt.imones.puslapis.projektopavadinimas.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;

@RestController
public class ReceptasController {

    @GetMapping("/test/greeting")
    String testinisEndpoint() {
        return "šis puslapis veikia";
    }
}

                            </code></pre>
                        </div>
                        <div class="spoiler-button">
                            <button></button>
                        </div>
                    </div></li>
                    <li>su @GetMapping žymime, kad šitas metodas bus susietas su tam tikru endpoint'u. @GetMapping yra naudojamas tiem metodams, kurie gaus kažkokią info iš DB. Tą endpointą nurodome GetMapping skliaustuose, šiuo atveju /test/greeting. Toliau, sukuriame metodo pavadinimą ir padarome, jog jis grąžintų String reikšmę "šis puslapis veikia", tai teisog šitą tekstą išves į naršyklės langą. (system out println nereikia, užtenka tiesiog grąžinti reikšmę per controllerį ir ji bus apdorota su model dalim ir nusiųsta į view)</li>
                    <li>Pabandome paleisti programą ir nueiti į <a href="http://localhost:8080/test/greeting">http://localhost:8080/test/greeting</a> nuorodą ir pažiūrėti ar išvedė mūsų tekstą. Jeigu išvedė tekstą - viskas gerai. Jeigu neišvedė teksto arba programa nepasileido - ieškokite klaidos arba rašykite man. <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-spring-boot/screenshot17.jpg" alt="Kodo foto"></div></span></li>
                    <li>Kai išbandėme, jog Controlleris veikia su endpoint'ais - reikia išbandyti "sujungimą" controllerio su Model package dalimi. Tai šiuo metu jau turėsime User/Endpoint -> Controller -> Model grandinę. Kad galėtume, pavyzdžiui, grąžinti norimą receptą ar įdėti norimą receptą - mums reikia ReceptasRepository interface, nes joje yra visi Duombazės metodai/funkcijos su receptais. Norint naudoti Model package'o ReceptasRepository klasės objektą, mums reikia jį "autowirinti". Tai yra specialus Spring Boot "įrankis", kuris sukuria specialius objektus programos pradžioj ir juos galime naudoti kitose klasėse, bet jų nesukuriant. Teoriškai, tą patį galima daryti ir paprastoje Javoje, tačiau reikia žymiai labiau atsižvelgti į tam tikras smulkmenas, išimtis ir taisykles. Naudojant Spring Boot, viskas truputį paprasčiau ir mums tereikia atsiminti, jog užtenka užsirašyti @Autowired ReceptasRepository kintamojoPavadinimas, kaip kad pvz.: <div class="spoiler">
                        <div class="spoiler-content">
                            <pre><code class="language-java">package lt.imones.puslapis.projektopavadinimas.controller;

import lt.imones.puslapis.projektopavadinimas.model.entity.Receptas;
import lt.imones.puslapis.projektopavadinimas.model.repository.ReceptasRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@RestController
public class ReceptasController {

    @Autowired
    ReceptasRepository receptasRepository;

    @GetMapping("/test/greeting")
    String testinisEndpoint() {
        return "šis puslapis veikia";
    }

}
                            </code></pre>
                        </div>
                        <div class="spoiler-button">
                            <button></button>
                        </div>
                    </div></li>
                    <li>Toliau, galime pasirašyti kelis metodus, kurie grąžintų tam tikrus duomenis. Tai turime ReceptasRepository klasėje vieną metodą, kuris randa receptą pagal Pavadinimą ir kitą metodą, kuris grąžina Receptus nuo iki tam tikros kainos. Mes su @GetMappingu galime susieti kad tam tikra nuoroda, atlieka tam tikrą veiksmą bei per parametrus galime nusakyti, kad per nuorodą gaus tam tikrus parametrus. Taigi Controlleris ir yra tas jungiamasis tarpininkas tarp nuorodų ir ReceptasRepository metodų. </li>
                    <li>Pasirašome pirmą metodą, kuris grąžins Receptą pagal pavadinimą. Kadangi pagal pavadinimą metodas grąžina vieną receptą, tai ir Controllerio metodas grąžins vieną Receptas klasės objektą. Kadangi ReceptasRepository metodui, kuris grąžina receptą pagal pavadinimą reikia recepto pavadinimo - jį metodas gaus iš nuorodos (get užklausos), bet vis vien turime įrašyti ir į skliaustus, jog gaus kaip parametrą. Skliaustuose su specialiu @RequestParam žymėjimu nusakysime, kad pavadinimas yra gaunamas iš nuorodos/get užklausos <div class="spoiler">
                        <div class="spoiler-content">
                            <pre><code class="language-java">package lt.imones.puslapis.projektopavadinimas.controller;

import lt.imones.puslapis.projektopavadinimas.model.entity.Receptas;
import lt.imones.puslapis.projektopavadinimas.model.repository.ReceptasRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@RestController
public class ReceptasController {

    @Autowired
    ReceptasRepository receptasRepository;

    @GetMapping("/test/greeting")
    String testinisEndpoint() {
        return "šis puslapis veikia";
    }


    @GetMapping("/recep/gauti_pav")
    Receptas gautiPagalPavadinima(@RequestParam String pavadinimas) {
        return receptasRepository.findByPavadinimas(pavadinimas);
    }

}
                            </code></pre>
                        </div>
                        <div class="spoiler-button">
                            <button></button>
                        </div>
                    </div> </li>
                    <li>Viršutiniame kode @GetMapping pažymėjome nuorodą pagal kurią reikėtų patekti į "puslapį", kuriame grąžins receptą pagal pavadinimą. @RequestParam pažymėjome String pavadinimas parodydami, kad šitą kintamąjį gausime per nuorodos parametrus. Returnina funkcija ReceptasRepository metodą findByPavadinimas(); na arba kitaip sakant kreipiasi į tą metodą. </li>
                    <li>Taigi, pavadinimas yra nuorodos parametras, bet kaip dabar išbandyti šią nuorodą? Get nuorodos, turinčios parametrus, yra užrašomos taip: "<b>nuoroda</b>" + "<b>?</b>" + "<b>pirmoParametroPavadinimas</b>" + "<b>=</b>" + "<b>pirmoParametroReiksme</b>" + "<b>%</b>" + "<b>antroParametroPavadinimas</b>" + "<b>=</b>" + "<b>antroParametroReiksme</b>" + "<b>%</b> + ketvirto, penkto ir t.t. kiek reikia (gali jų ir nebūti, kaip kad pvz. greeting nuorodai)</li>
                    <li>Tarpas, dažniausiai yra žymimas pliuso (+) ženklu, kadangi nuorodose tarpų būti negali.</li>
                    <li>Todėl, norėdami surasti receptą pavadinimu Mutinys, turėtume daryti užklausą tokia nuoroda: <a href="http://localhost:8080/recep/gauti_pav?pavadinimas=Mutinys">http://localhost:8080/recep/gauti_pav?pavadinimas=Mutinys</a>, o norint surasti receptą pavadinimu Bulvių košė, reikia daryti užklausą tokia nuoroda: <a href="http://localhost:8080/recep/gauti_pav?pavadinimas=Bulvi%C5%B3+ko%C5%A1%C4%97">http://localhost:8080/recep/gauti_pav?pavadinimas=Bulvi%C5%B3+ko%C5%A1%C4%97</a> <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-spring-boot/screenshot18.jpg" alt="Kodo foto"></div></span></li>
                    <li>Kaip matote iš viršutinės Bulvių košė nuorodos, lietuviškos raidės gaunasi gan nepatogios nuorodos, TAČIAU, IŠ TIKRŲJŲ GALIMA RAŠYTI TIESIOG http://<a href="http://localhost:8080/recep/gauti_pav?pavadinimas=Bulvi%C5%B3+ko%C5%A1%C4%97">localhost:8080/recep/gauti_pav?pavadinimas=Bulvių+košė</a>, tiesiog dabartinės naršyklės jau moka automatiškai lietuviškas raides konvertuoti į užšifruotus lotyniškus simbolius. Jeigu matote viršutiniame paveiksliukyje: rezultatas yra grąžinamas labai "sausai" ir sunkiai įskaitomai. Pažymėjau abiejų rezultatų pagrindinius duomenis: matome, jog grąžina Mutinys, kitas rezultatas grąžina Bulvių košė, tai kaip ir rezultatai yra geri, tačiau matome ten toliau surašo dar ir daug kitų receptų. Taip yra todėl, nes kiekvienas receptas turi vartotoją, o pas mane duombazėje yra gal ~10-20 receptų, kurie yra pirmo vartotojo. Kadangi Mutinys ir Bulvių košė priklauso pirmam vartotojui, o jie abu turi receptoKurejas kintamąjį, kuris yra Vartotojas, o tas turi Set'ą savo receptų, tai gaunasi, jog prie recepto turime dar ir visus kitus to pačio vartotojo receptus bei jų ingredientus - tai yra gan daug nebūtinai reikalingos informacijos.</li>
                    <li>Ją galima įvairiais būdais stengtis sumažinti - galbūt nereikia saugoti visų vartotojų receptų, o juos gauti tik su funkcija, kai jų reikės. Galbūt pasidaryti custom (savadarbes) užklausas, kurios grąžintų ne pagal sugeneruotą modelį, o pagla tiek kiek mums informacijos reikia. Tačiau, kol dar tik tai pati pradžia su Spring Boot apie tai per daug galvoti nederėtų - šiuolaikiniai kompiuteriai yra greiti ir užduotys nėra milžiniško masto, jog optimizacija sudarytų daug įtakos.</li>
                    <li>Bet kokiu atvejo, tokius rezultatus skaityti ir matyti yra labai nepatogu. Taip pat, kuo toliau tuo tas užklausas rašyti bus nepatogu, o kai bandysime daryti POST (duomenų įdėjimo) užklausą iš vis susidursime su didelėmis problemomis rašydami užklausas paprastai per naršyklę. Kad viskas būtų paprasčiau, tam yra sukurta speciali programa: <a href="https://www.postman.com/downloads/">Postman</a></li>
                </div>
            </div> 
            <div class="section">
                <div class="section-header">
                    <h3 id="section1">Controller metodų ir rezultatų testavimas su Postman programa. Užklausų kūrimas.</h3>
                </div>
                <div class="theory-text">
                    <li>Parsisiunčiame  <a href="https://www.postman.com/downloads/">Postman programą iš šios nuorodos,</a> kadangi nors ir ją eina naudoti neparsisiuntus, bet norint dirbti su lokaliu (wamp) serveriu reikia papildomų pluginų, tad geriausia iš karto parsisiųsti pilną desktopinę versiją. Prieš arba po parsisiuntimo tikriausiai gali reikėti užsiregistruoti norint pilnai naudotis programa.</li>
                    <li>Kai jau užsiregistravote, parsisiuntėte ir įsirašėte programą - įsijunkite ją ir prisijunkite prie savo paskyros. <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-spring-boot/screenshot19.jpg" alt="Kodo foto"></div></span> Raudona spalva - pažymėta Worskpaces tai čia būtų įprasta kurtis skirtingus projektus. Žalia spalva yra pažymėta Collections, čia dažniausiai galima grupuoti projekto užklausas į grupes arba jei mažesnis projektas tiesiog turėti jo visas užklausa vienam collection. Pvz., pas mane tai yra skirtingų kursų workspace'ai ir skirtingų pamokų/pavyzdžių collectionai. Šiame paveiksliuke yra mūsų dabartinio pavyzdžio collection'as. Jeigu norite prisidėti Collection į savo programą spauskite mėlyna spalva pažymėtą pliusiuką. Jeigu norite prisidėti kažką kito (Workspace, Užklausę) spauskite New (truputį dešiniau į viršų nuo pliuso)</li>
                    <li>Paspaudžiame ant sukurto Collection, jog jį atidaryti ir tada spaudžiame arba ant New (raudona rodyklė) arba ant Add request (raudona rodyklė) <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-spring-boot/screenshot20.jpg" alt="Kodo foto"></div></span></li>
                    <li>Jeigu spaudėte ant New, tai dabar reikėtų rinktis Request <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-spring-boot/screenshot21.jpg" alt="Kodo foto"></div></span></li>
                    <li>Toliau, atidaro langą, kuriame reikia surašyti duomenis apie užklausą <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-spring-boot/screenshot22.jpg" alt="Kodo foto"></div></span> Raudona rodykle pažymėtas užklausos pavadinimas - čia tiesiog kaip jūs patys norite pasivadinti šitą užklausą, kad būtų patogiau matyti. Mėlyna rodykle - užklausos tipas. Kadangi mes gauname duomenis bei controlleryje šiai nuorodai yra GetMapping, tai parenkame GET. Žalia užklausa reikės suvesti nuorodą. VISOS NUORODOS RAŠYTI NEREIKĖS, tik mūsų serverio nuorodą (localhost:8080) ir endpoint'o nuorodą (nukopijuoti iš controllerio). Rožiniai rašome parametrų pavadinimus, o šalia geltonai rašome to parametro reiškmę.</li>
                    <li>Taigi, pavadinimo nekeičiam pakol kas. Užklausos tipą nustatome GET. Į nuorodą įrašome http://localhost:8080/ ir nukopijuojame iš Controllerio endpoint'ą. <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-spring-boot/screenshot23.jpg" alt="Kodo foto"></div></span></li>
                    <li>Toliau, turime surašyti parametrus. Tai šita užklausa turi vieną parametrą: pavadinimas, jį ir įrašome, jog bus Mutinys. <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-spring-boot/screenshot24.jpg" alt="Kodo foto"></div></span></li>
                    <li>Paspaudžiame save ir užvadiname savo užklausą (nes jei neišsaugosime, gali viskas išsitrint ir neliks kitam kartui). <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-spring-boot/screenshot25.jpg" alt="Kodo foto"></div></span></li>
                    <li>Toliau, spaudžiame "Send" ir apačioje matysime rezultatą. Jis, žinoma vis vien yra tik tekstas, bet dabar jau yra žymiai patogiau suformatuotas tekstas, kurį galime ir sutraukti ir suskleisti. <span class="open-image"><img src="../assets/img/img.png" alt="Paveiksliukas rodantis du paveiksliukus, skirtas atidaryti paveiksliuką"><div><img src="../assets/img/java-spring-boot/screenshot26.jpg" alt="Kodo foto"></div></span> P.S. FORMATAVIMAS GALI UŽTRUKTI</li>

                </div>
            </div>
        </div>
    </div>
</body>
</html>